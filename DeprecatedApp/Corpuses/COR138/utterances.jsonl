{"id": "ROOT", "speaker": "reyjrar", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2017-12-28T22:12:37Z", "text": "Conditionally import_playbook aka include_playbook ##### ISSUE TYPE\r  - Feature Idea\r \r ##### COMPONENT NAME\r import_playbook\r \r ##### ANSIBLE VERSION\r <!--- Paste verbatim output from \"ansible --version\" between quotes below -->\r ```\r 2.4.0.0\r ```\r \r ##### CONFIGURATION\r <!---\r If using Ansible 2.4 or above, paste the results of \"ansible-config dump --only-changed\"\r Otherwise, mention any settings you have changed/added/removed in ansible.cfg\r (or using the ANSIBLE_* environment variables).\r -->\r \r n/a\r \r ##### OS / ENVIRONMENT\r \r CentOS 6\r \r ##### SUMMARY\r \r I need to conditionally import a playbook, which isn't possible.  The keyword I'm missing is \"include_playbook\" which would allow a \"when\" to apply to it.  Why?\r \r I have a playbook that performs some maintenance, OS, Kernel, package, and firmware upgrades.  For Major upgrades, we track progress in a ticketing system.  So, during those runs, I'd like to conditionally import a playbook that updates the ticket information.  In order for that to work, I need to pass the user's password to the ticketing system, so there's a `vars_prompt` in the ticket update playbook.  If the user specifies which ticket they're working to the maintenance playbook, I'd like the ticket update playbook to be called after the maintenance is performed.\r \r If there's another way for this to work, I'm open to alternate ideas, but I think conditionally playbook imports would be generically useful.  I'm not understanding why tasks could be included dynamically, but a playbook wouldn't be.\r \r ##### STEPS TO REPRODUCE\r <!---\r For bugs, show exactly how to reproduce the problem, using a minimal test-case.\r For new features, show how the feature would be used.\r -->\r \r <!--- Paste example playbooks or commands between quotes below -->\r ```yaml\r # Maintenance Play Runs first, then conditionally import a second playbook\r - import_playbook: update-ticket.yaml\r   when: ticket_id is defined\r ```\r \r <!--- You can also paste gist.github.com links for larger files -->\r \r ##### EXPECTED RESULTS\r <!--- What did you expect to happen when running the steps above? -->\r \r I expect `update-ticket.yaml` to only import if the `ticket_id` is defined.\r \r ##### ACTUAL RESULTS\r <!--- What actually happened? If possible run with extra verbosity (-vvvv) -->\r \r no parse error, and playbook `update-ticket.yaml` is imported 100% of the time.\r ", "meta": {"posReactions": "103", "negReactions": "0"}}
{"id": "COM0", "speaker": "ansibot", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2017-12-28T22:18:52Z", "text": "Files identified in the description:\n* [lib/ansible/modules/utilities/logic/import_playbook.py](https://github.com/ansible/ansible/blob/devel/lib/ansible/modules/utilities/logic/import_playbook.py)\n\nIf these files are inaccurate, please update the `component name` section of the description or use the `!component` bot command.\n\n[click here for bot help](https://github.com/ansible/ansibullbot/blob/master/ISSUE_HELP.md)\n<!--- boilerplate: components_banner --->", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "MarSik", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2018-01-29T15:17:35Z", "text": "We have similar need. We have a main playbook that prepares the system, but we allow the user to provide some extra steps by creating a playbook files in a well known directories. We do not know what files will be present there in advance. For this we would really like to have include_playbook that supports with_fileglob (or with_items).", "meta": {"posReactions": "4", "negReactions": "0"}}
{"id": "COM2", "speaker": "MarSik", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2018-01-29T15:21:43Z", "text": "Just to explain why include_tasks is not enough. The system is clustered and the tasks talk to localhost, other physical hosts and virtual machines. We could in theory use delegate_to if it supported host groups.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM3", "speaker": "TonyApuzzo", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2018-03-22T02:21:37Z", "text": "I also have this need in order to import different playbooks to configure Vagrant guests differently depending on the active hypervisor.\r\n\r\nAlternate to `when` is something like (this is also not supported):\r\n```YAML\r\n- import_playbook: \"install_{{ 'virtualbox' if ansible_product_name == 'VirtualBox' else 'vmware' if ansible_product_name = 'VMware Virtual Platform' else 'noop' }}_extensions.yml\"\r\n```\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM4", "speaker": "ssbarnea", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2018-04-23T09:27:31Z", "text": "Is this going to be fixed soon? I find it as a serious source of problems because the optional playbook code ca be huge when it comes to number of tasks, causing over **extensive console/log verbosity** of tasks that are never supposed to be loaded.\r\n\r\nThe `skip_reason\": \"Conditional result was False\"` is not of much help either because the user will not see any condition on those tasks, the condition being few nested includes/imports away in another file.\r\n\r\nIt helps nobody that Ansible will list hundreds of lines of files that were never supposed to be run, making much harder to investigate them.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM5", "speaker": "user140547", "conversation_id": "ROOT", "reply_to": "COM4", "timestamp": "2018-05-05T20:55:47Z", "text": "As a workaround until this is possible, if the use case is to support different host groups it is possible to use an include_task with a conditional on group names, i.e. a task include for a group `foo` is included when a file `tasks_directory/foo.yml` is provided:\r\n\r\n```\r\n- include_tasks: \"{{item}}\"\r\n  with_fileglob: \"tasks_directory/*.yml\"\r\n  vars:\r\n    file_host_group: \"{{ (item | basename | splitext)[0]}}\"\r\n  when: \"file_host_group in group_names\"\r\n```\r\n\r\nThe playbook including this construct has to run for all hosts.\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM6", "speaker": "watsonb", "conversation_id": "ROOT", "reply_to": "COM5", "timestamp": "2018-08-31T19:06:38Z", "text": "Is this still being worked at all?  I'm kind of implementing something like an `ansible-galaxy` style method of \"installing\" playbooks into a playbooks sub-directory and then I want to `include_playbook` a playbook that was just \"installed\".  \r\n\r\nHere is what I've got so far:\r\n\r\n```yaml\r\n- name: PLAY | Install other required playbooks\r\n  hosts: localhost\r\n  connection: local\r\n  tasks:\r\n\r\n    - name: INCLUDE_VARS | include variables to discover other needed playbooks\r\n      include_vars:\r\n        dir: playbooks/\r\n        files_matching: requirements.yml\r\n        depth: 1\r\n\r\n    - name: GIT | Clone playbooks\r\n      git:\r\n        repo: \"{{ item.src }}\"\r\n        dest: \"playbooks/{{ item.src.split('/')[-1] }}\"\r\n        version: \"{{ item.version }}\"\r\n      loop: \"{{ elk_required_playbooks }}\"\r\n\r\n    - name: SHELL | Install included playbooks roles\r\n      shell: ansible-galaxy install -r roles/requirements.yml -p roles/\r\n      args:\r\n        chdir: \"playbooks/{{ item.src.split('/')[-1] }}\"\r\n      loop: \"{{ elk_required_playbooks }}\"\r\n\r\n- name: PLAY | Run the installed helloWorld playbook\r\n  import_playbook: \"playbooks/ap_hello_world/helloWorld.yml\"\r\n```\r\nIf I run this as-is, I get an import error because the playbook to be imported isn't there yet.\r\n\r\n```bash\r\nERROR! Unable to retrieve file contents\r\nCould not find or access '/path/to/playbooks/ap_hello_world/helloWorld.yml'\r\n```\r\nIf I comment out the `import_playbook` play, the functionality above that works nearly like `ansible-galaxy` and \"installs\" the playbooks I need (and the roles they need).  \r\n\r\n```bash\r\nPLAY [PLAY | Install other required playbooks] *************************************************************************************************************************************\r\n\r\nTASK [Gathering Facts] *************************************************************************************************************************************************************\r\nFriday 31 August 2018  13:54:13 -0500 (0:00:00.239)       0:00:00.240 ********* \r\nFriday 31 August 2018  13:54:13 -0500 (0:00:00.237)       0:00:00.237 ********* \r\nok: [localhost]\r\n\r\nTASK [INCLUDE_VARS | include variables to discover other needed playbooks] *********************************************************************************************************\r\nFriday 31 August 2018  13:54:15 -0500 (0:00:01.366)       0:00:01.606 ********* \r\nFriday 31 August 2018  13:54:15 -0500 (0:00:01.366)       0:00:01.604 ********* \r\nok: [localhost]\r\n\r\nTASK [GIT | Clone playbooks] *******************************************************************************************************************************************************\r\nFriday 31 August 2018  13:54:15 -0500 (0:00:00.124)       0:00:01.730 ********* \r\nFriday 31 August 2018  13:54:15 -0500 (0:00:00.124)       0:00:01.728 ********* \r\nchanged: [localhost] => (item={u'src': u'<gir_url>/ap_hello_world', u'version': u'v0.3.0'})\r\n\r\nTASK [SHELL | Install included playbooks roles] ************************************************************************************************************************************\r\nFriday 31 August 2018  13:54:17 -0500 (0:00:02.591)       0:00:04.322 ********* \r\nFriday 31 August 2018  13:54:17 -0500 (0:00:02.591)       0:00:04.319 ********* \r\nchanged: [localhost] => (item={u'src': u'<git_url>/ap_hello_world', u'version': u'v0.3.0'})\r\n\r\nPLAY RECAP *************************************************************************************************************************************************************************\r\nlocalhost                  : ok=4    changed=2    unreachable=0    failed=0 \r\n```\r\nAnd now I can run the same playbook again, this time with the `import_playbook` play not commented and it works as I desire:\r\n\r\n```bash\r\nPLAY [PLAY | Install other required playbooks] *************************************************************************************************************************************\r\n\r\nTASK [Gathering Facts] *************************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:30 -0500 (0:00:00.244)       0:00:00.244 ********* \r\nFriday 31 August 2018  14:00:30 -0500 (0:00:00.241)       0:00:00.241 ********* \r\nok: [localhost]\r\n\r\nTASK [INCLUDE_VARS | include variables to discover other needed playbooks] *********************************************************************************************************\r\nFriday 31 August 2018  14:00:32 -0500 (0:00:01.471)       0:00:01.716 ********* \r\nFriday 31 August 2018  14:00:32 -0500 (0:00:01.471)       0:00:01.713 ********* \r\nok: [localhost]\r\n\r\nTASK [GIT | Clone playbooks] *******************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:32 -0500 (0:00:00.138)       0:00:01.854 ********* \r\nFriday 31 August 2018  14:00:32 -0500 (0:00:00.138)       0:00:01.852 ********* \r\nok: [localhost] => (item={u'src': u'<git_url>/ap_hello_world', u'version': u'v0.3.0'})\r\n\r\nTASK [SHELL | Install included playbooks roles] ************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:35 -0500 (0:00:02.821)       0:00:04.675 ********* \r\nFriday 31 August 2018  14:00:35 -0500 (0:00:02.821)       0:00:04.673 ********* \r\nchanged: [localhost] => (item={u'src': u'<git_url>/ap_hello_world', u'version': u'v0.3.0'})\r\n\r\nPLAY [PLAY | BEGIN Setup & Timing] *************************************************************************************************************************************************\r\n\r\nTASK [set_fact] ********************************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:36 -0500 (0:00:01.323)       0:00:05.999 ********* \r\nFriday 31 August 2018  14:00:36 -0500 (0:00:01.323)       0:00:05.997 ********* \r\nok: [localhost]\r\n\r\nTASK [debug] ***********************************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:36 -0500 (0:00:00.155)       0:00:06.154 ********* \r\nFriday 31 August 2018  14:00:36 -0500 (0:00:00.155)       0:00:06.152 ********* \r\nok: [localhost] => {\r\n    \"msg\": \"Start Time - 2018-08-31 14:00:36\"\r\n}\r\n\r\nPLAY [PLAY | Say Hello to My Little Friend] ****************************************************************************************************************************************\r\n\r\nTASK [SHELL | echo something] ******************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:36 -0500 (0:00:00.096)       0:00:06.251 ********* \r\nFriday 31 August 2018  14:00:36 -0500 (0:00:00.096)       0:00:06.249 ********* \r\nok: [knebawils001]\r\n\r\nTASK [DEBUG | debug host's standard output] ****************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:37 -0500 (0:00:00.714)       0:00:06.965 ********* \r\nFriday 31 August 2018  14:00:37 -0500 (0:00:00.714)       0:00:06.963 ********* \r\nskipping: [knebawils001]\r\n\r\nPLAY [PLAY | Say Hello via an Ansible Role] ****************************************************************************************************************************************\r\n\r\nTASK [ar_hello_world : SHELL | echo role's message on host] ************************************************************************************************************************\r\nFriday 31 August 2018  14:00:37 -0500 (0:00:00.151)       0:00:07.117 ********* \r\nFriday 31 August 2018  14:00:37 -0500 (0:00:00.151)       0:00:07.115 ********* \r\nok: [knebawils001]\r\n\r\nTASK [ar_hello_world : DEBUG | debug host shell standard output] *******************************************************************************************************************\r\nFriday 31 August 2018  14:00:37 -0500 (0:00:00.342)       0:00:07.459 ********* \r\nFriday 31 August 2018  14:00:37 -0500 (0:00:00.342)       0:00:07.457 ********* \r\nskipping: [knebawils001]\r\n\r\nPLAY [PLAYBOOK | END Setup & Timing] ***********************************************************************************************************************************************\r\n\r\nTASK [set_fact] ********************************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:38 -0500 (0:00:00.212)       0:00:07.672 ********* \r\nFriday 31 August 2018  14:00:38 -0500 (0:00:00.212)       0:00:07.669 ********* \r\nok: [localhost]\r\n\r\nTASK [debug] ***********************************************************************************************************************************************************************\r\nFriday 31 August 2018  14:00:38 -0500 (0:00:00.179)       0:00:07.851 ********* \r\nFriday 31 August 2018  14:00:38 -0500 (0:00:00.178)       0:00:07.848 ********* \r\nok: [localhost] => {\r\n    \"msg\": \"Start Time - 2018-08-31 14:00:36, End Time - 2018-08-31 14:00:38, Elapsed Time - 0:00:02\"\r\n}\r\n\r\nPLAY RECAP *************************************************************************************************************************************************************************\r\nknebawils001          : ok=2    changed=0    unreachable=0    failed=0   \r\nlocalhost                  : ok=8    changed=1    unreachable=0    failed=0\r\n```\r\nI suppose this could be split up into two (2) separate playbooks in the same Git repo.  The first would be called `prepare.yml` or maybe `prerequisites.yml` to \"install\" the other needed playbooks and the second main playbook (`playbook.yml`) will do the necessary imports, etc.  I was really wanting to make this a \"one-shot\" playbook.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM7", "speaker": "gunbo13", "conversation_id": "ROOT", "reply_to": "COM6", "timestamp": "2018-09-11T15:27:00Z", "text": "Include conditionals are very useful for creating branches in our playbooks.  Will it be ensured that import_playbook will support conditionals in the next release citing this issue?\r\n\r\nIf not, you are losing a lot of power and will end up creating a lot of hacks.  Not to mention breaking a ton of include playbook conditionals in end user plays.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM8", "speaker": "davedittrich", "conversation_id": "ROOT", "reply_to": "COM7", "timestamp": "2018-09-24T04:10:28Z", "text": "+1 on implementing a \"when\" conditional.", "meta": {"posReactions": "14", "negReactions": "0"}}
{"id": "COM9", "speaker": "DanyC97", "conversation_id": "ROOT", "reply_to": "COM8", "timestamp": "2018-10-03T21:31:39Z", "text": "soon-ish we approaching 1 y since this request was open and no progress so far ...  any chance this get some attention @bcoca ? much thanks !", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM10", "speaker": "tonk", "conversation_id": "ROOT", "reply_to": "COM9", "timestamp": "2018-10-10T08:58:25Z", "text": "I would like to vote a '+1'as well.", "meta": {"posReactions": "0", "negReactions": "1"}}
{"id": "COM11", "speaker": "ivovangeel", "conversation_id": "ROOT", "reply_to": "COM10", "timestamp": "2018-10-10T11:24:10Z", "text": "+1", "meta": {"posReactions": "0", "negReactions": "1"}}
{"id": "COM12", "speaker": "SDerksen", "conversation_id": "ROOT", "reply_to": "COM11", "timestamp": "2018-10-10T14:04:16Z", "text": "+1 as well, would love to see this feature", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM13", "speaker": "sebastiaanluca", "conversation_id": "ROOT", "reply_to": "COM12", "timestamp": "2018-10-10T14:10:29Z", "text": "Please use the \ud83d\udc4d  button to let the maintainers know you need this feature. Getting a ton of emails from these +1s.", "meta": {"posReactions": "32", "negReactions": "0"}}
{"id": "COM14", "speaker": "rfjschutte", "conversation_id": "ROOT", "reply_to": "COM13", "timestamp": "2018-10-12T11:32:02Z", "text": "+1", "meta": {"posReactions": "0", "negReactions": "4"}}
{"id": "COM15", "speaker": "amarao", "conversation_id": "ROOT", "reply_to": "COM14", "timestamp": "2018-10-18T14:41:38Z", "text": "If someone is interested how to use play-level variables for conditional playbook-import:\r\n1. Set up that variable as a fact in the play\r\n2. Use `when` with `import_playbook` to check this variable (with full path, `hostvars.hostname.a_variable`)\r\n\r\nIf someone is interested, I managed to make import_playbook be conditional on `--limit` in the command line:\r\n\r\nhttps://medium.com/opsops/import-playbook-with-play-level-condition-775122fe78ff\r\n\r\nAn example:\r\n\r\n```\r\n- hosts: all,localhost\r\n  gather_facts: no\r\n  run_once: True\r\n  tasks:\r\n   - set_fact:\r\n        full_run: '{{ play_hosts == groups.all }}'\r\n     delegate_to: localhost\r\n     delegate_facts: yes\r\n\r\n- import_playbook: test.yaml\r\n  when: hostvars.localhost.full_run\r\n```", "meta": {"posReactions": "4", "negReactions": "0"}}
{"id": "COM16", "speaker": "brotaxt", "conversation_id": "ROOT", "reply_to": "COM15", "timestamp": "2019-04-02T09:38:34Z", "text": "is this issue/request still up to date in a more current version of ansible? Iam using ansible 2.6.1 and the when condition doesn't seem to work when I use the import_playbook function.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM17", "speaker": "amarao", "conversation_id": "ROOT", "reply_to": "COM16", "timestamp": "2019-04-02T10:00:11Z", "text": "@brotaxt  You need to initialize variables before doing `when`. Just add some random task to random host (before doing first 'import_playbook'). F.e., do set_fact on localhost, as in example above.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM18", "speaker": "brotaxt", "conversation_id": "ROOT", "reply_to": "COM17", "timestamp": "2019-04-02T13:47:30Z", "text": "@amarao \r\n\r\nmany thanks for the quick response. :+1:  Unfortunately it doesn't seem to work for me. Even if answer the prompt with \"no\" the playbook \"vmware_createsnap.yml\" gets invoked. The other tasks are working as expected. What I am doing wrong? \r\n\r\n\r\nMy playbook: \r\n\r\n```\r\n---\r\n-\r\n  hosts: all\r\n  gather_facts: true\r\n  vars_prompt:\r\n   - name: \"snapshots_required\"\r\n     prompt: \"Do you want to automatically create VMWare Snapshots? [yes/no]\"\r\n     private: no\r\n  name: \"Install all available Updates\"\r\n  tasks:\r\n\r\n   - name: Check for Updates\r\n     include: checkforupdates.yml\r\n\r\n   - name: setting fact for hosts which have outstanding updates\r\n     set_fact:\r\n       updates_available: \"yes\"\r\n     when: \"yumoutput.changed or zypperoutput.changed\"\r\n\r\n\r\n   - name: setting fact for hosts which have no outstanding updates\r\n     set_fact:\r\n       updates_available: \"false\"\r\n     when: updates_available is not defined\r\n\r\n\r\n- import_playbook: vmware_createsnap.yml\r\n  when: snapshots_required = \"yes\"\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM19", "speaker": "bcoca", "conversation_id": "ROOT", "reply_to": "COM18", "timestamp": "2019-04-02T14:09:58Z", "text": "@brotaxt  this is a feature request, you currently CANNOT conditionally import playbooks, the conditions above happen to skip all the tasks in one, but this is not a supported behaviour and not guaranteed to work across versions of Ansible.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM20", "speaker": "Kriechi", "conversation_id": "ROOT", "reply_to": "COM19", "timestamp": "2019-04-02T14:14:33Z", "text": "just to be clear:\r\nimport or include? because I think the current implementation or naming is actually wrong, based on the definition in https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_includes.html\r\n\r\nDoes import_playbook actually \"lazy load\" or does it get loaded & parsed with the yaml file?", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM21", "speaker": "bcoca", "conversation_id": "ROOT", "reply_to": "COM20", "timestamp": "2019-04-02T14:28:04Z", "text": "@Kriechi neither, it gets loaded at 'playbook compile time' which is before execution but not on file load\r\n\r\nthere is no include_playbook, that is the whole purpose of this feature request, to add one", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM22", "speaker": "Kriechi", "conversation_id": "ROOT", "reply_to": "COM21", "timestamp": "2019-04-02T14:31:08Z", "text": "@bcoca mhm that sounds even more wrong - or am I missing the big picture here?\r\nI would have expected that `import_task` and `include_task` have an `*_playbook` sibling...", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM23", "speaker": "bcoca", "conversation_id": "ROOT", "reply_to": "COM22", "timestamp": "2019-04-02T14:32:46Z", "text": "@Kriechi the engine never supported that, why `include:` was very misleading and we had to separate it into the different include_X/import_X options and make each behaviour explicit. So include_X is dynamic aka runtime, while import_X is 'static' aka 'compile time'.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM24", "speaker": "Kriechi", "conversation_id": "ROOT", "reply_to": "COM23", "timestamp": "2019-04-02T14:36:14Z", "text": "ok - so `include_playbook` would be a feature request? Or can we track it here?\r\n\r\nE.g., I'm running a git-checkout task on localhost, and then want to `include_playbook: some/repo/foo.yml`\r\nThis should include (lazy-load) the updated playbook from that repository, AFTER pulling the latest commit from the remote. Currently, `import_playbook` imports the \"old\" playbook, then pulls, and then runs the outdated playbook.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM25", "speaker": "bcoca", "conversation_id": "ROOT", "reply_to": "COM24", "timestamp": "2019-04-02T15:23:28Z", "text": "@Kriechi  ... please read the subject of this ticket, that is EXACTLY what we are tracking here", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM26", "speaker": "Kriechi", "conversation_id": "ROOT", "reply_to": "COM25", "timestamp": "2019-04-02T15:37:22Z", "text": "true - the part the confused me is \"conditionally import...\".\r\n`import_playbook` and `include_playbook` are the feature we want.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM27", "speaker": "decet", "conversation_id": "ROOT", "reply_to": "COM26", "timestamp": "2019-05-23T17:30:07Z", "text": "I'm trying to do what [watsonb](https://github.com/ansible/ansible/issues/34281#issuecomment-417762220) was, using ansible-galaxy to install roles, and then using the roles. \r\n\r\nI found a decent workaround for the all-in-one playbook, which was to place the playbooks, in the order that you want them to execute, on the command line. In Watsonb's case, that would look like\r\n\r\nansible-playbook ... prepare.yml playbook.yml\r\n\r\nAny variables that you set on the command line are passed to the playbooks, sequentially.\r\n\r\nThis might also solve [MarSik's](https://github.com/ansible/ansible/issues/34281#issuecomment-361277446) problem, also, using file globbing on the command line instead of in the playbook.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM28", "speaker": "MarSik", "conversation_id": "ROOT", "reply_to": "COM27", "timestamp": "2019-05-23T18:47:20Z", "text": "@decet It could, but that would basically mean using a top level bash script as the entrypoint and spliting the main ansible playbook into multiple stage files. Not too horrible, just ugly.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM29", "speaker": "watsonb", "conversation_id": "ROOT", "reply_to": "COM28", "timestamp": "2019-05-24T00:37:55Z", "text": "I've overcome this in my own way as follows.  First, my typical playbook directory structure:\r\n\r\n```bash\r\n.\r\n\u251c\u2500\u2500 .ansible-lint\r\n\u251c\u2500\u2500 .gitignore\r\n\u251c\u2500\u2500 .yamllint\r\n\u251c\u2500\u2500 ansible.cfg\r\n\u251c\u2500\u2500 callback_plugins\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 junit.py\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 log_plays.py\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 profile_roles.py\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 profile_tasks.py\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 timer.py\r\n\u251c\u2500\u2500 check_ansible_lint.sh\r\n\u251c\u2500\u2500 check_syntax.sh\r\n\u251c\u2500\u2500 check_yaml_lint.sh\r\n\u251c\u2500\u2500 create.yml\r\n\u251c\u2500\u2500 destroy.yml\r\n\u251c\u2500\u2500 Jenkinsfile\r\n\u251c\u2500\u2500 localhost_inventory.yml\r\n\u251c\u2500\u2500 playbooks\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ap_linux_instance\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 requirements.yml\r\n\u251c\u2500\u2500 prerequisites.yml\r\n\u251c\u2500\u2500 README.md\r\n\u251c\u2500\u2500 reports\r\n\u251c\u2500\u2500 requirements.txt\r\n\u251c\u2500\u2500 roles\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ar_linux_ansible_venv\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 ar_linux_cname\r\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 config_encoder_filters\r\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 requirements.yml\r\n\u2514\u2500\u2500 VERSION.md\r\n```\r\n\r\nMy .gitignore ignores most sane OS/language/IDE things, but also ignores everything in the `roles/` and `playbooks/` folders except for the `requirements.yml` files in each folder.  The requirements.yml file within the playbooks folder is similar to your Galaxy-style requirements.yml, but rather than calling out dependent playbooks by Galaxy owner.name, I specify the full Git source (Galaxy supports this of course).  The requirements.yml within the roles/ folder is just your traditional Galaxy-style requirements.\r\n\r\nI have this `prerequisites.yml` playbook, that looks like this:\r\n\r\n```yaml\r\n---\r\n\r\n- name: PLAY | Install other required playbooks\r\n  hosts: localhost\r\n  connection: local\r\n  tasks:\r\n\r\n    - name: INCLUDE_VARS | include variables to discover other needed playbooks\r\n      include_vars:\r\n        dir: playbooks/\r\n        files_matching: requirements.yml\r\n        depth: 1\r\n\r\n    - name: GIT | Clone playbooks\r\n      git:\r\n        repo: \"{{ item.src }}\"\r\n        dest: \"playbooks/{{ item.src.split('/')[-1] }}\"\r\n        version: \"{{ item.version }}\"\r\n      loop: \"{{ required_playbooks }}\"\r\n\r\n    - name: SHELL | Install included playbooks roles\r\n      shell: ansible-galaxy install -r roles/requirements.yml -p roles/ --force\r\n      args:\r\n        chdir: \"playbooks/{{ item.src.split('/')[-1] }}\"\r\n      loop: \"{{ required_playbooks }}\"\r\n      when: item.galaxy\r\n      changed_when: false\r\n      tags: [ skip_ansible_lint ]\r\n```\r\nAnd, assuming that my \"big bang\" create.yml depends on a playbook and its roles from another playbook project, I import it like this:\r\n\r\n```yaml\r\n# ~~~~~~~~~~\r\n# Ensure that all of the host VMs in the inventory are up and running\r\n# either on-prem or in Azure as specified in the inventory\r\n#\r\n- name: Ensure inventory hosts are present\r\n  import_playbook: \"playbooks/ap_linux_instance/create.yml\"\r\n  tags: [ base_server, hosts ]\r\n```\r\n\r\nAnd so, the work-flow to run my \"big bang\" (e.g. create.yml) is a 3-liner:\r\n\r\n```bash\r\nansible-playbook prerequisites.yml\r\nansible-galaxy install -r roles/requirements -p roles/\r\nansible-playbook create.yml -i <path_to_inventory>\r\n```\r\n\r\nYou could, of course, wrap the above 3-liner in a `create.sh` shell script for convenience.  This method has served me well for some fairly complex playbook projects that depend on other playbook projects.  This forces us to keep roles and playbooks fairly self-contained and re-usable and factor variables out into their own inventory projects.  When performed with discipline, it makes it really easy to migrate unaltered roles/playbooks to other environments, then just update inventory variables that are unique to that environment.\r\n\r\n**This doesn't solve the conditional import problem**, mind you, but does help me use the `import_playbook` statement for something that may not exist just yet.  It kind of gets around a conditional in my very specific use-case.  I make use of tagging on the `import_playbook` to leverage the command-line `--tags` and `--skip-tags` features if I need scalpel-like precision at run-time. But if you had to make an import decision based on some other conditional logic (e.g., OS family), well, we still need that as a language feature I think.  For now, I just handle those cases with sub-playbooks and chain them together ensuring I target the appropriate hosts/groups that should or should not be targeted based on how I've setup my inventory (yes, it can get messy).\r\n\r\nThis is all pretty wild and requires a high degree if what I commonly refer to as \"4th dimensional thinking\", especially when you consider branches/versions of things and running them from CI/CD platforms like Jenkins or even AWX.  But I still find Ansible fascinating and use it daily.\r\n\r\nHTH,\r\n\r\nBen", "meta": {"posReactions": "1", "negReactions": "0"}}
