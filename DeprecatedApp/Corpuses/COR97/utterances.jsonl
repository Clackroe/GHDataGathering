{"id": "ROOT", "speaker": "lll000111", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2019-07-20T10:43:52Z", "text": "Array.isArray refinement loses the array's type I realize there are  a number of related issues. However, some where about ReadonlyArray, some didn't see directly related at all even though it was pointed there.\r \r Also, this is a much smaller example, just a single line of code really:\r \r [Playground link](http://www.typescriptlang.org/play/index.html#code/GYVwdgxgLglg9mABAEwKYFs4AoZQFyICSUqATgIYBGANqgDxgjqVkB8AlAY82QNoC6iAN4AoROMQQEAZyiJypCgE9EAXkQBBReSUA6GNK3KcUdogD8iXIgK9d93PwDcIsRID07xABFU1GCwUJFy6tGAA5lAAFlbS8oiypDARiOio0XDIADSIlCByYHCIZKRwpLmoEOQg0qiIcMCIUEoADnUARORgSu2IwGWIYG7ipOkgpEgKyrro5C1YSKqsg6GoEdHsLgC+IkA)\r \r ```js\r function demo(it: Iterable<number>): number[] {\r     // THIS LINE: \"array\" is any[]\r     const array = Array.isArray(it) ? it : [...it];\r     // Deliberate: n.length is a string method, but no error because of type \"any\" for n\r     return array.map(n => n.length);\r }\r ```\r \r I know people will point to this ir that implementation or design decision detail &mdash; honestly guys, you got it REVERSED. The tool should serve the purpose, not the other way around!\r \r That the array loses all it's type information in such a simple example is A BUG.\r \r And **it is possible** to do much better: [See here!](https://flow.org/try/#0GYVwdgxgLglg9mABAEwKYFs4AoZQFyICSUqATgIYBGANqgDxgjqVkB8AlAY82QNoC6iAN4AoROMQQEAZyiJypCgE9EAXkQBBReSUA6GNK3KcUdogD8iXIgK9d93PwDcYiQHo3iACKpqMFhQkXLq0YADmUAAWVtLyiLKkMOGI6KhRcMgANIiUIHJgcIhkpHCkOagQ5CDSqIhwwIhQSgAOtQBE5GBKbYjApYhgruKkaSCkSArKuujkzVhIqqwDIajhUewuAL4iQA) I'm only pointing this out because at times the responses sound like \"We tried everything but it is just not possible\" when the competition shows that it *is* actually quite possible.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM0", "speaker": "AnyhowStep", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2019-07-20T11:38:55Z", "text": "As a workaround, add overloads to Array.isArray() using declaration merging?", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "fatcerberus", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2019-07-20T12:32:12Z", "text": "Don\u2019t underestimate how difficult things like this are from a theoretical perspective.  Humans are much better at figuring these things out than computers.\r\n\r\nIn the *general case*, the compiler can\u2019t safely deduce that `Generic1<number> \u2014> Generic2<number>` unless both are in the union to be narrowed, because the type parameter might be used for different purposes in both types.\r\n\r\nIn this *specific case*, though, adding an overload:\r\n```ts\r\nisArray<T>(x: Iterable<T>): x is Array<T>\r\n```\r\nwould likely suffice.  I suspect this is probably how Flow does it.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM2", "speaker": "fatcerberus", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2019-07-20T12:48:10Z", "text": "Proof of concept:\r\n[Try in TS Playground](https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgIJSnAngYQPYgDOYUArgmHlAFADe1yjywh6mWAPACoB8AFHCgBzAFzIAkpEwAjADYRuPAJRjBQ5oTQZsigNzUAvtWoxSICsALIAJhAC2ePsDBjJ0OHIUhSd6dGVi3r7QANoAusj0TMgIBMTIguzIALxa7AB0LGzYTmBKyAD8zGDIYiHpFc5h+tFQEGCkUCAJ2ljpdnAADnzNyTzIIOnyIEJgABZKuowA9NPI0FBUYgDkIMsaAz5+NEZAA)\r\n\r\n```ts\r\ninterface ArrayConstructor\r\n{\r\n    isArray<T>(arg: Iterable<T>): arg is Array<T>;\r\n}\r\n\r\nfunction demo(it: Iterable<number>): number[] {\r\n    const array = Array.isArray(it) ? it : [...it];\r\n    return array.map(n => n.length);  // error: 'n' is number\r\n}\r\n```\r\n\r\n---\r\n\r\nFor the record, the current declaration of `isArray` is:\r\n```ts\r\n    isArray(arg: any): arg is Array<any>;\r\n```\r\n\r\nI wonder if that can be improved.  I'll need to give that some thought and maybe I'll open a PR.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM3", "speaker": "lll000111", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2019-07-20T12:59:23Z", "text": "> Don\u2019t underestimate how difficult things like this are from a theoretical perspective\r\n\r\nI don't. I too write code. And...?\r\n\r\nA problem is a problem. If you decide to solve it what's the point of saying in the middle \"okay now it's too difficult\". I trust that there are very capable people working on this project who will _find a way_. :-)\r\n", "meta": {"posReactions": "0", "negReactions": "5"}}
{"id": "COM4", "speaker": "fatcerberus", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2019-07-20T13:09:32Z", "text": "> And...? :-)\r\n\r\nThen you should already know that things that *appear* trivial can, in fact, turn out to be intractable, and being combative about that helps no one.\r\n\r\nBut anyway, in this case TS indeed has a mechanism (overloads) that can solve the problem, see above.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM5", "speaker": "lll000111", "conversation_id": "ROOT", "reply_to": "COM4", "timestamp": "2019-07-20T13:16:49Z", "text": "> and being combative about that helps no one.\r\n\r\nSo _why are you_ being combative? Please check a mirror. Did you a) (only) respond to the issue, or did you b) choose to unnecessarily attack my experience? Not to mention that half of your first response was about something I had already covered in my initial post.\r\n\r\nAlso, I know the problem can be solved. So your point is? If a problem can be solved using \"obvious methods\" it does not have to be actually done (no need to report the issue))? Are you a mathematician? The theoretical solution is enough, \"I'll leave it to the reader to complete this trivial proof for themselves\"?\r\n", "meta": {"posReactions": "0", "negReactions": "8"}}
{"id": "COM6", "speaker": "kitsonk", "conversation_id": "ROOT", "reply_to": "COM5", "timestamp": "2019-07-21T09:13:02Z", "text": "> So why are you being combative?\r\n\r\nSo feels like it is the other way around to me. \ud83e\udd37\u200d\u2642 ", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM7", "speaker": "RyanCavanaugh", "conversation_id": "ROOT", "reply_to": "COM6", "timestamp": "2019-07-22T19:56:32Z", "text": "@lll000111 your attitude here makes my day measurably worse. Lots of people here manage to be constructive and positive and I'd appreciate your effort in not starting fights with us or other contributors. I've asked you to do this once already and am not going to ask a third time - if you continue to be combative to people just trying to help, we'll be asking you to discontinue your engagement on the issue tracker.\r\n\r\nTurning to the issue at hand, I think we need to figure out what the right solution is relative to #17002. In that issue (`Array.isArray` and `ReadOnlyArray<T>`), it seemed like the preference from people was that narrowing e.g. `string | ReadonlyArray<number>` with `isArray` should yield `ReadonlyArray<number>`. not `Array<number>`.\r\n\r\nIt'd be confusing if `string | Iterable<number>` narrowed to `Iterable<number>` but narrowing `Iterable<number>` produced `Array<number>` - the `isArray` type guard should uniformly either produce a subtype or filter a union, not do one or the other depending on whether the argument type has some unrelated (e.g. known-`false`-returning) union constituents.\r\n\r\nAlso an open question: surely it's not *just* `Iterable` and `ReadonlyArray` that want special treatment? Are there other types? How does this impact #28916", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM8", "speaker": "lll000111", "conversation_id": "ROOT", "reply_to": "COM7", "timestamp": "2019-07-22T20:11:24Z", "text": "@RyanCavanaugh Please don't @-mention me in threads I'm not subscribed to. I refer to what I already wrote above. Your comment is insulting and more than useless. Go and learn some manners!", "meta": {"posReactions": "0", "negReactions": "2"}}
{"id": "COM9", "speaker": "fatcerberus", "conversation_id": "ROOT", "reply_to": "COM8", "timestamp": "2019-07-22T21:02:02Z", "text": "@RyanCavanaugh Interestingly, writing a type predicate `x is ReadonlyArray<T>` doesn\u2019t actually work from my tests: it narrows to `T[]` (sans readonly-ness) anyway.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM10", "speaker": "zpdDG4gta8XKpMCd", "conversation_id": "ROOT", "reply_to": "COM9", "timestamp": "2019-07-22T22:17:15Z", "text": "bitch needs a slap", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM11", "speaker": "DanielRosenwasser", "conversation_id": "ROOT", "reply_to": "COM10", "timestamp": "2019-07-23T00:06:31Z", "text": "Alright, I am going to lock this issue. We can't tolerate abrasive language or tone on this issue tracker, and it has clearly become a problem here, so I'm closing the thread. Insults, disrespectful tone, and consistently abrasive language are violations of our [code of conduct](https://opensource.microsoft.com/codeofconduct/).\r\n\r\nKeep in mind that violations of the code of conduct can result in being banned. I always try to remind participants that we are *all* striving to make TypeScript better - but if you want to participate, the only way to do so is with respect. If you cannot do that, we cannot allow you to engage on the issue tracker.", "meta": {"posReactions": "0", "negReactions": "0"}}
