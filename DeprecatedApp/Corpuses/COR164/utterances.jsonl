{"id": "ROOT", "speaker": "votdev", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2019-09-17T08:58:08Z", "text": "mount.mounted does not handle blanks properly Currently it is not possible to mount a filesystem to a mount point that contains blanks.\r \r There are many problems in the ``states.mount.mounted`` code path, e.g. the mount command arguments are not quoted in the ``modules.mount.mount`` function, see \r https://github.com/saltstack/salt/blob/develop/salt/modules/mount.py#L1237. \r \r Code should look like this IMO:\r ```\r cmd = 'mount {0} {1} {2} '.format(args, device, shlex.quote(name))\r ```\r But this will fix only a small piece of the whole problem.\r \r Another one is that ``states.mount.mounted`` does not detect correctly that the filesystem might be mounted already, i think it's because the key in the active table is not unquoted, so a comparison between\r ``/srv/dev-disk-by-label-My\\040Passport\\040Blue`` and the specified ``/srv/dev-disk-by-label-My Passport Blue`` fails.\r \r To me it looks like the whole mount state and module is not able to handle blanks in device names and mount points properly.\r \r Example SLS:\r ```\r mount_fs_with_label:\r   mount.mounted:\r     - name: \"/srv/dev-disk-by-label-My Passport Blue\"\r     - device: \"/dev/disk/by-label/My\\\\x20Passport\\\\x20Blue\"\r     - fstype: ext4\r     - mkmnt: True\r     - persist: False\r     - mount: True\r ```\r \r Result:\r ```\r           ID: mount_fs_with_label\r     Function: mount.mounted\r         Name: /srv/dev-disk-by-label-My Passport Blue\r       Result: False\r      Comment: mount: bad usage\r               Try 'mount --help' for more information.\r      Started: 08:31:10.286521\r     Duration: 181.307 ms\r      Changes: \r ```\r \r ```\r # salt-call mount.active\r ...\r  /srv/dev-disk-by-label-My\\040Passport\\040Blue:\r         ----------\r         alt_device:\r             None\r         device:\r             /dev/sda1\r         fstype:\r             ext4\r         opts:\r             - rw\r             - noexec\r             - relatime\r             - jqfmt=vfsv0\r             - usrjquota=aquota.user\r             - grpjquota=aquota.group\r ...\r ```\r \r ```\r # ls -alh /dev/disk/by-label/\r total 0\r drwxr-xr-x 2 root root  60 Sep 17 08:29  .\r drwxr-xr-x 7 root root 140 Sep 17 08:29  ..\r lrwxrwxrwx 1 root root  10 Sep 17 08:29 'My\\x20Passport\\x20Blue' -> ../../sda1\r ```\r \r ```\r # ls -alh /srv\r total 28K\r drwxr-xr-x  7 root root    4.0K Sep 17 08:07  .\r drwxr-xr-x 21 root root    4.0K Sep 16 16:07  ..\r drwxr-xr-x  4 root root    4.0K Sep 13 13:40  dev-disk-by-id-scsi-0QEMU_QEMU_HARDDISK_drive-scsi0-0-2-part1\r drwxr-xr-x  2 root root    4.0K Sep 16 16:11 'dev-disk-by-label-My Passport Blue'\r drwxr-xr-x  2 ftp  nogroup 4.0K Sep 10 14:23  ftp\r drwxr-xr-x  3 root root    4.0K Sep 16 16:07  pillar\r drwxr-xr-x  5 root root    4.0K Sep 16 16:07  salt\r ```\r \r ```\r # cat /etc/fstab\r proc /proc proc defaults 0 0\r UUID=90ee6298-385f-4841-bfdc-8b1e0e0ae5c1 / ext4 errors=remount-ro 0 1\r # >>> [openmediavault]\r /dev/disk/by-label/My\\x20Passport\\x20Blue\t\t/srv/dev-disk-by-label-My\\040Passport\\040Blue\text4\tdefaults,nofail,user_xattr,noexec,usrjquota=aquota.user,grpjquota=aquota.group,jqfmt=vfsv0,acl\t0 2\r # <<< [openmediavault]\r ```\r \r ```\r # cat /proc/self/mountinfo\r ...\r 265 25 8:1 / /srv/dev-disk-by-label-My\\040Passport\\040Blue rw,noexec,relatime shared:148 - ext4 /dev/sda1 rw,jqfmt=vfsv0,usrjquota=aquota.user,grpjquota=aquota.group\r ...\r ```\r ", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM0", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2021-03-28T04:34:34Z", "text": "Hello, @votdev \r\n\r\nI am trying to build myself home NAS with old Atom mini-ITX board... So i install OMV5, i plug in dad's old NTFS drive... and here we go...\r\n\r\nFrankly, i wish Salt guys put the comments inside this source, listing all the bugs related to this module. So any hacker which for whatever reason would change it - would be instantly notifie on old pending bugs.\r\n\r\nSalt seems extremely fragile here, probably no one else except for OMV5 uses it for partitions. Maybe OMV6 could do it outside Salt? Like good old UDEV rules or anything. I mean, before Salt porject might decide to drop this functionality that almost no one use, instead of burden of maintaining it for OMV5 alone....\r\n\r\nWell, ranting aside, i am rather puzzled with your _device: \"/dev/disk/by-label/My\\\\x20Passport\\\\x20Blue\"_\r\nWhere do you even get this hex substitution from???\r\n\r\nThing is, the whole mounting escaping is one uber-ancient legacy mess. Putting it here so maybe someone would use it. I spent like 3 hours googling around and experimenting with Python that i never used before. Tryied to google some standard about Posix/Linux/bash filename mangling/escaping.... and then Python module to undo it. To no avail.\r\n\r\nOkay, so, to document it down.\r\n\r\n- mtab/fstab and friends is one-of-a-kind ancient mess.\r\n- it started with ancient BSD (not FreeBSD) function strunvis, which behaviour  not documented. Probably that was OS-specific function (a la virtual methods). http://manpages.org/strunvis/3\r\n- when Linux was mimicking good old BSd it only made ad hoc substitutions for 4 specific chars. There is no any systematic/generic pattern at all.\r\n\r\n```\r\nstatic inline void mangle(struct seq_file *m, const char *s)\r\n{\r\n\tseq_escape(m, s, \" \\t\\n\\\\\");\r\n}\r\n```\r\nhttps://elixir.bootlin.com/linux/latest/source/fs/proc_namespace.c#L84\r\n\r\n```\r\n\t\t\t\tR(\"\\\\\", '\\\\'),\r\n\t\t\t\tR(\"011\", '\\t'),\r\n\t\t\t\tR(\"012\", '\\n'),\r\n\t\t\t\tR(\"040\", ' '),\r\n\t\t\t\tR(\"134\", '\\\\')\r\n```\r\nhttps://sources.debian.org/src/sysvinit/2.96-6/src/fstab-decode.c/\r\n\r\nSo, whatever comes from Linux mounts information - should be de-mangled for those four special cases.\r\nEvery single space-separated column of every single line.\r\nUgly, and undocumented, but that is what it is. And, frankly, it is not that hard...\r\n\r\nBUT, why do you want to compare with some arbitrary hex-escaped string? what can be a real use-case for that???\r\nLinux kernel just does not have hex-escaping code for disk mounts.\r\n\r\nNow, to be frank, even this would NOT be enough, because i can have multiple disks with the same partition label. Like many USB thumb drives with \"DATA\" partition. I can even have several partitions with the same name on singe disk!\r\n\r\nAgain, it can be fixed by detecting collisions and adding extra data, like counters or GUID or whatever, but...\r\n\r\nWhat gonna OMV do if OMV's user has two drives with partitions having same labels, and then he hotplugs one disk, or another, or both in any order? Is it race condition now? Is it okay for OMV to have race condition?\r\nSeems whatever use cases Salt imagined for them here is very different from what OMV users might face.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2021-03-28T04:58:15Z", "text": "Output from Linux's mount\r\n`/dev/sdb1 on /media/U:NTFS Disk type fuseblk (rw,relatime,user_id=0,group_id=0,allow_other,blksize=4096)`\r\n\r\nSpaces are NOT escaped there!\r\nDunno how it is done on BSD/Darwin\r\n\r\nAnd then we have this...\r\n```\r\n# salt-call mount.list_mounts\r\nlocal:\r\n    ----------\r\n    /:\r\n        /dev/sda1\r\n......\r\n    /media/U:NTFS:\r\n        /dev/sdb1\r\n    /proc:\r\n        proc\r\n........\r\n```\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM2", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2021-03-28T06:26:46Z", "text": "@votdev  re: escaping names for calling `mount` - i think that is what was intended to do so:\r\n\r\n`\"device\": device_name.replace(\"\\\\040\", \"\\\\ \"),` inside `def _active_mountinfo()`\r\nbut that was only called when from `def active(extended=False)` then Extended is set to True, if ever\r\n\r\nAnd similar code inside `def _resolve_user_group_names(opts):`\r\n\r\nSo it seems Salt prefers to keep space-containing names mangled, but mangled differently.\r\nSo, no escaping when calling `mount` or `umount` is needed,\r\n\r\n---\r\n\r\nI am not even sure that de-escaping mount point likes `xxx\\040yyy` in Salt would be correct way to go.\r\n\r\nThere can be a point: since that module serves as abstraction layer and should hide UNIX-likes peculiarities from generic Salt modules, all IDs better be unmangled. But not sure. \r\n\r\nHowever IF to do this de-mangling, then quoting arguments for calling `mount` becomes required indeed.\r\n\r\nBut anyway, this line i believe  should not had ended in /etc/fstab and whoever added it was at fault...\r\n\r\n```\r\n# >>> [openmediavault]\r\n/dev/disk/by-label/My\\x20Passport\\x20Blue\t\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM3", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2021-03-28T09:38:18Z", "text": "@votdev i made quite many changes in that mounts.py - and now i am thinking about undoing almost all of them... Lack of any documentation...\r\n\r\nI am coming to believe that, while never documented, the intention of that Salt module was to always use fstab-like escaped strings for all their IDs. If not, i would like to see specific calls into other Salt modules, which expect different convention for disk names.\r\n\r\nI really did quite a number of changes to de-escape \\040 and other special chars. And probably that was only breaking things.\r\n\r\nExcept for one place though, which i believe should be patched.\r\n\r\n```\r\nimport pathlib \r\n\r\ndef list_mounts(): # for debug\r\n    return _list_mounts()\r\n\r\ndef _list_mounts():\r\n    ret = {}\r\n    idx_mpoint = 2\r\n    # one cannot trust `mount` with space-containing paths\r\n    # at least on Linux - https://github.com/saltstack/salt/issues/54508\r\n\r\n    if __grains__[\"kernel\"] == \"Linux\":\r\n        idx_mpoint = 1\r\n        mounts = pathlib.Path('/proc/mounts').read_text()\r\n    elif __grains__[\"os\"] in [\"MacOS\", \"Darwin\"]:\r\n        mounts = __salt__[\"cmd.run_stdout\"](\"mount\")\r\n    else:\r\n        mounts = __salt__[\"cmd.run_stdout\"](\"mount -l\")\r\n\r\n    for line in mounts.split(\"\\n\"):\r\n        comps = re.sub(r\"\\s+\", \" \", line).split()\r\n        if len(comps) > idx_mpoint:\r\n##            if __grains__[\"kernel\"] == \"Linux\":\r\n##               comps[0] = _Linux_fstab_unmangle( comps[0] )\r\n##               comps[idx_mpoint] = _Linux_fstab_unmangle( comps[idx_mpoint] )\r\n            ret[comps[idx_mpoint]] = comps[0]\r\n    return ret\r\n```\r\n\r\nWould you keep implementation non-patched and would you call `salt-call mount.list_mounts` - you would see the mount point broken, cut off on the first space. This was probably THE bug.\r\n\r\n----------------\r\n\r\nOkay, keeping my stolen Linux archeologist hat on\r\n\r\nhttps://unix.stackexchange.com/questions/56291/what-causes-dev-disk-by-label-to-be-populated\r\n\r\n```\r\nmount -l \r\n   .....\r\n/dev/sdb1 on /media/U:NTFS Disk type fuseblk (rw,relatime,user_id=0,group_id=0,allow_other,blksize=4096) [U - Arch-2 Hitachi_2Tb_7200]\r\n\r\nroot@diskoteka:/media# ls /dev/disk/by-label/\r\n'U\\x20-\\x20Arch-2\\x20Hitachi_2Tb_7200'\r\n\r\nroot@diskoteka:/media# blkid -o udev -p /dev/sdb1\r\nID_FS_LABEL=U_-_Arch-2_Hitachi_2Tb_7200\r\nID_FS_LABEL_ENC=U\\x20-\\x20Arch-2\\x20Hitachi_2Tb_7200\r\nID_FS_UUID=C6705D84705D7BDD\r\nID_FS_UUID_ENC=C6705D84705D7BDD\r\nID_FS_TYPE=ntfs\r\nID_FS_USAGE=filesystem\r\nID_PART_TABLE_TYPE=atari\r\nID_PART_ENTRY_SCHEME=dos\r\nID_PART_ENTRY_UUID=78fdd16a-01\r\nID_PART_ENTRY_TYPE=0x7\r\nID_PART_ENTRY_NUMBER=1\r\nID_PART_ENTRY_OFFSET=2048\r\nID_PART_ENTRY_SIZE=3907024896\r\nID_PART_ENTRY_DISK=8:16\r\n```\r\n\r\nSo, it is UDEV or SYSTEMD which creates those weird hex-mangled names. Okay. Though putting them into /etc/fstab still feels wrong. `man mount` suggests against it and suggests using `UUID=...` and `LABEL=...` flags instead.\r\n\r\nNow back to your\r\n```\r\nExample SLS:\r\n\r\nmount_fs_with_label:\r\n  mount.mounted:\r\n    - name: \"/srv/dev-disk-by-label-My Passport Blue\"\r\n```\r\n\r\nI don't know what it should mean in specific files/commands terms. But i feel this is the error on OMV part. And perhaps lack of documentation/understanding/forecasting on Salt part.\r\n\r\n```\r\ndef mount(\r\n    name, device=False, mkmnt=False, fstype=\"\", opts=\"defaults\", user=None, util=\"mount\"\r\n):\r\n.....\r\n        salt '*' mount.mount /mnt/foo /dev/sdz1 True\r\n.....\r\n    if device:\r\n        cmd += \"{} {} {} \".format(args, device, name)\r\n    else:\r\n        cmd += \"{} \".format(name)\r\n```\r\n\r\nMy inner archeologist says that the `name` AKA mount point AKA target directory is meant to be in bash-mangled format.\r\nIOW OMV should had created \"\\ \" containing fileneames:\r\n```\r\n  mount.mounted:\r\n    - name: \"/srv/dev-disk-by-label-My\\ Passport\\ Blue\"\r\n```\r\nLinux `man mount` also suggests against the second option due to ambiguity, where the single parameter is mount point name or device file name. I don't know if other UNIX-likes but Linux support those precision keys.\r\n\r\n```\r\n       --source device\r\n              If only one argument for the mount command is given  then  the\r\n              argument might be interpreted as target (mountpoint) or source\r\n              (device).  This option allows to explicitly  define  that  the\r\n              argument is the mount source.\r\n\r\n       --target directory\r\n              If  only  one argument for the mount command is given then the\r\n              argument might be interpreted as target (mountpoint) or source\r\n              (device).   This  option  allows to explicitly define that the\r\n              argument is the mount target.\r\n```\r\n\r\nSo i think that part in `def mount` should better be written as\r\n\r\n```\r\n    if device:\r\n        cmd += \"{} {} {} \".format(args, device, name)\r\n    else:\r\n        if __grains__[\"kernel\"] == \"Linux\":\r\n             cmd += \"--target \"\r\n        cmd += \"{} \".format(name)\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM4", "speaker": "votdev", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2021-03-28T09:38:45Z", "text": "@the-Arioch I don't think this is the right place to discuss OMV related things.\r\n\r\n> Well, ranting aside, i am rather puzzled with your device: \"/dev/disk/by-label/My\\x20Passport\\x20Blue\"\r\n> Where do you even get this hex substitution from???\r\n\r\nEscaping blanks is not my idea, it is used by every userland command that processes mount points, e.g. `mount`.\r\nEither `systemd` want to have escaped paths in mount units too, there is a special command to convert\r\npaths for you, see `systemd-escape`.\r\n\r\n> Salt seems extremely fragile here, probably no one else except for OMV5 uses it for partitions. \r\n> Maybe OMV6 could do it outside Salt?\r\n\r\nOMV already workarounds this issue, thus it is not affected by this reported issue here.\r\n\r\n> I mean, before Salt porject might decide to drop this functionality that almost no one use, \r\n> instead of burden of maintaining it for OMV5 alone....\r\n\r\nI don't think Salt will drop `mount.mounted` because it is a somewhat essential functionality of Linux systems.\r\n\r\n> Now, to be frank, even this would NOT be enough, because i can have multiple disks with the \r\n> same partition label. Like many USB thumb drives with \"DATA\" partition. I can even have several \r\n> partitions with the same name on singe disk!\r\n\r\nYou can do that, but don't blame the software then. Using USB devices in a NAS is no good idea, but that's a different thing. IMO devices using in a NAS should be already connected to the NAS, no plug-and-play, this is not how a NAS is intended to work. If devices are always connected, then you will never run into the situation that duplicate labels might harm your system. This issue is user introduced and should be handled by them.\r\n\r\nIf you want to discuss this issue please open an issue in the OMV Git repository.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM5", "speaker": "votdev", "conversation_id": "ROOT", "reply_to": "COM4", "timestamp": "2021-03-28T09:46:06Z", "text": "> So, it is UDEV or SYSTEMD which creates those weird hex-mangled names. Okay. Though putting them into /etc/fstab still feels wrong. \r\n\r\nI think it is ok to use systemd escaped paths in `/etc/fstab` since systemd handles filesystem mounting nowadays.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM6", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM5", "timestamp": "2021-03-28T10:15:49Z", "text": "@votdev i meantioned systemd because of https://github.com/systemd/systemd/issues/12018\r\n\r\nSee... i know very little about Linux and nothing about Python, so i was googling everything i could think of :-)\r\n\r\nBut i am glad to hear from you.  So, how can we scratch this itch, is Salt team is not with us on it...\r\n\r\nCan you make some scripts demonstrting the alleged Salt bug that i could run from bash ? Also are there some hidden option in OMV5 to re-enable mounting space-containing partitions?\r\n\r\n\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM7", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM6", "timestamp": "2021-03-28T10:17:44Z", "text": "But i really am worried about potential race conditions in OMV when different partitions would have same label... IF you use label as \"primary key\" as persistent ID for all the other settings (user rights, sharing folders, etc), it might be quite a gotcha...", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM8", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM7", "timestamp": "2021-03-28T10:26:46Z", "text": "Some of the \"deep changes\" i mentioned above. I now think those are dead end, but just in case they would be useful to someone, maybe even us later.\r\n\r\nUsing \"Raw\" non-escaped string would probably be more proper design, but might really require deep refactoring of many Salt modules and then testing on many different systems. Horror...\r\n\r\n```\r\ndef _Linux_fstab_unmangle(fs_str):\r\n    # rather ugly ad-hoc substitutions cosplaying ancient BSD's non-documented strunvis(...)\r\n    # https://sources.debian.org/src/sysvinit/2.96-6/src/fstab-decode.c/\r\n    # https://elixir.bootlin.com/linux/latest/source/fs/proc_namespace.c#L84\r\n    fs_str = fs_str.replace(r\"\\011\", \"\\t\").replace(r\"\\012\", \"\\n\")\r\n    fs_str = fs_str.replace(r\"\\040\", r\" \")\r\n    fs_str = fs_str.replace(r\"\\134\", \"\\\\\").replace(r\"\\\\\", \"\\\\\")\r\n    return fs_str\r\n\r\ndef _Str_Nop(text):\r\n    return str(text)\r\n\r\ndef _fsfilter():\r\n    if __grains__[\"kernel\"] == \"Linux\":\r\n        return _Linux_fstab_unmangle\r\n    return _Str_Nop\r\n```\r\n\r\nand then\r\n\r\n```\r\ndef _list_mounts():\r\n    ret = {}\r\n    idx_mpoint = 2\r\n    # one cannot trust `mount` with space-containing paths\r\n    # at least on Linux - https://github.com/saltstack/salt/issues/54508\r\n\r\n    if __grains__[\"kernel\"] == \"Linux\":\r\n        idx_mpoint = 1\r\n        mounts = pathlib.Path('/proc/mounts').read_text()\r\n    elif __grains__[\"os\"] in [\"MacOS\", \"Darwin\"]:\r\n        mounts = __salt__[\"cmd.run_stdout\"](\"mount\")\r\n    else:\r\n        mounts = __salt__[\"cmd.run_stdout\"](\"mount -l\")\r\n\r\n    for line in mounts.split(\"\\n\"):\r\n        comps = re.sub(r\"\\s+\", \" \", line).split()\r\n        if len(comps) > idx_mpoint:\r\n            if __grains__[\"kernel\"] == \"Linux\":\r\n               comps[0] = _Linux_fstab_unmangle( comps[0] )\r\n               comps[idx_mpoint] = _Linux_fstab_unmangle( comps[idx_mpoint] )\r\n            ret[comps[idx_mpoint]] = comps[0]\r\n    return ret\r\n\r\n\r\ndef _active_mountinfo_linux(ret):\r\n    _list = _list_mounts()\r\n    _fi = _fsfilter()\r\n    filename = \"/proc/self/mountinfo\"\r\n    if not os.access(filename, os.R_OK):\r\n        msg = \"File not readable {0}\"\r\n        raise CommandExecutionError(msg.format(filename))\r\n\r\n    if \"disk.blkid\" not in __context__:\r\n        __context__[\"disk.blkid\"] = __salt__[\"disk.blkid\"]()\r\n    blkid_info = __context__[\"disk.blkid\"]\r\n\r\n    with salt.utils.files.fopen(filename) as ifile:\r\n        for line in ifile:\r\n            comps = salt.utils.stringutils.to_unicode(line).split()\r\n            device = comps[2].split(\":\")\r\n            # each line can have any number of\r\n            # optional parameters, we use the\r\n            # location of the separator field to\r\n            # determine the location of the elements\r\n            # after it.\r\n            _sep = comps.index(\"-\")\r\n            device_name = _fi(comps[_sep + 2])\r\n            device_uuid = None\r\n            device_label = None\r\n            if device_name:\r\n                device_uuid = blkid_info.get(device_name, {}).get(\"UUID\")\r\n                device_uuid = device_uuid and device_uuid.lower()\r\n                device_label = blkid_info.get(device_name, {}).get(\"LABEL\")\r\n            ret[_fi(comps[4])] = {\r\n                \"mountid\": comps[0],\r\n                \"parentid\": comps[1],\r\n                \"major\": device[0],\r\n                \"minor\": device[1],\r\n                \"root\": _fi(comps[3]),\r\n                \"opts\": _resolve_user_group_names(comps[5].split(\",\")),\r\n                \"fstype\": comps[_sep + 1],\r\n                \"device\": device_name, ## .replace(\"\\\\040\", \"\\\\ \"),\r\n                \"alt_device\": _list.get(_fi(comps[4]), None),\r\n                \"superopts\": _resolve_user_group_names(comps[_sep + 3].split(\",\")),\r\n                \"device_uuid\": device_uuid,\r\n                \"device_label\": device_label,\r\n            }\r\n    return ret\r\n\r\n\r\ndef _active_mounts_linux(ret):\r\n    \"\"\"\r\n    List active mounts on Linux systems\r\n    \"\"\"\r\n    _list = _list_mounts()\r\n    _fi = _fsfilter()\r\n    filename = \"/proc/self/mounts\"\r\n    if not os.access(filename, os.R_OK):\r\n        msg = \"File not readable {0}\"\r\n        raise CommandExecutionError(msg.format(filename))\r\n\r\n    with salt.utils.files.fopen(filename) as ifile:\r\n        for line in ifile:\r\n            comps = salt.utils.stringutils.to_unicode(line).split()\r\n            ret[_fi(comps[1])] = {\r\n                \"device\": _fi(comps[0]),\r\n                \"alt_device\": _list.get(_fi(comps[1]), None),\r\n                \"fstype\": comps[2],\r\n                \"opts\": _resolve_user_group_names(comps[3].split(\",\")),\r\n            }\r\n    return ret\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM9", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM8", "timestamp": "2021-03-28T11:05:59Z", "text": "@votdev  > OMV already workarounds this issue\r\n\r\nby failing to mount the disk? because i can not mount disk in OMV5 or i would never learn about this issue.\r\nfailing to mount disk does not look like work-around at all.\r\n\r\nlet's think what we can do to make space-containing partitions mounted by OMV. It seems to be a kind of \"communication breakdown\" between Salt and OMV5, they expect and provide for mututally incompatible things.\r\n\r\nhere is minimally patched \r\n/usr/lib/python3/dist-packages/salt/modules/mount.py \r\n\r\n[mount.py.gz](https://github.com/saltstack/salt/files/6217180/mount.py.gz)\r\n\r\n\r\nit makes space-containing mount point visible. If there still is something not working - i can not see what it is and how could i test it using `salt-call` scripts\r\n\r\n```\r\n# salt-call mount.list_mounts\r\nlocal:\r\n    ----------\r\n    /:\r\n        /dev/sda1\r\n    /dev:\r\n        udev\r\n    /dev/hugepages:\r\n        hugetlbfs\r\n    /dev/mqueue:\r\n        mqueue\r\n    /dev/pts:\r\n        devpts\r\n    /dev/shm:\r\n        tmpfs\r\n    /media/U:NTFS\\040Disk:\r\n        /dev/sdb1\r\n    /proc:\r\n        proc\r\n......\r\n# salt-call mount.active\r\n....\r\n   /media/U:NTFS\\040Disk:\r\n        ----------\r\n        alt_device:\r\n            /dev/sdb1\r\n        device:\r\n            /dev/sdb1\r\n        fstype:\r\n            fuseblk\r\n        opts:\r\n            - rw\r\n            - relatime\r\n            - user_id=0\r\n            - group_id=0\r\n            - allow_other\r\n            - blksize=4096\r\n..........\r\n# salt-call mount.active extended=true\r\n......\r\n   /media/U:NTFS\\040Disk:\r\n        ----------\r\n        alt_device:\r\n            /dev/sdb1\r\n        device:\r\n            /dev/sdb1\r\n        device_label:\r\n            U - Arch-2 Hitachi_2Tb_7200\r\n        device_uuid:\r\n            c6705d84705d7bdd\r\n        fstype:\r\n            fuseblk\r\n        major:\r\n            8\r\n        minor:\r\n            17\r\n        mountid:\r\n            427\r\n        opts:\r\n            - rw\r\n            - relatime\r\n        parentid:\r\n            26\r\n        root:\r\n            /\r\n        superopts:\r\n            - rw\r\n            - user_id=0\r\n            - group_id=0\r\n            - allow_other\r\n            - blksize=4096\r\n```\r\nand also\r\n```\r\nroot@diskoteka:/media# salt-call mount.is_mounted name=\"/media/U:NTFS Disk\"\r\nlocal:\r\n    False\r\nroot@diskoteka:/media# salt-call mount.is_mounted name=\"/media/U:NTFS\\ Disk\"\r\nlocal:\r\n    False\r\nroot@diskoteka:/media# salt-call mount.is_mounted name=\"/media/U:NTFS\\040Disk\"local:\r\n    True\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM10", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM9", "timestamp": "2021-03-28T11:41:02Z", "text": "And now the most curious thing to me. I changed the partition label, then i mounted the disk from OMV Web UI and...\r\n\r\n....and there is no any space-containing mountpoint path regardless of partition label.\r\nThe \"workaround\" seems to needlessly shoot down the perfectly working function!\r\n\r\nMaybe it is only with MBR/NTFS disks, maybe GPT or XFS disks would use something else in `fstab`, dunno\r\n\r\n```\r\n# mount -l\r\n    ....\r\n/dev/sdb1 on /srv/dev-disk-by-uuid-C6705D84705D7BDD type fuseblk (rw,relatime,user_id=0,group_id=0,allow_other,blksize=4096) [U_-_Arch-2_Hitachi_2Tb_7200]\r\n```\r\nand\r\n\r\n```\r\n# salt-call mount.active\r\n  . . . .\r\n    /srv/dev-disk-by-uuid-C6705D84705D7BDD:\r\n        ----------\r\n        alt_device:\r\n            /dev/sdb1\r\n        device:\r\n            /dev/sdb1\r\n        fstype:\r\n            fuseblk\r\n        opts:\r\n            - rw\r\n            - relatime\r\n            - user_id=0\r\n            - group_id=0\r\n            - allow_other\r\n            - blksize=4096\r\n    /sys:\r\n        ----------\r\n        alt_device:\r\n            sysfs\r\n```\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM11", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM10", "timestamp": "2021-03-29T17:34:41Z", "text": "@votdev it is sad how fast you were to say Salt is all wrong and how protective you fet about OMV.\r\n\r\nYou still try to push Salt to adhere to OMV data format, while common sense says it should be otherwise.\r\n\r\nSalt users would not suffer from it. OMV users would.\r\nDemanding PR from OMV users like me is funny when you did not make any PR to Salt, or maybe i am wrong and you did.\r\n\r\nSo, back to:\r\n\r\nhttps://github.com/openmediavault/openmediavault/issues/566#issuecomment-809541057\r\n\r\nThe intention was and is to make OMV work with disks users insert. \r\nWithout forcing them to go ssh sudo. \r\nSo simple.\r\n\r\nYou make it look that making OMV \"just work\" is bad goal. \r\n\r\n> Why the hell should escapeshellarg be called here?\r\n\r\nBecause that woul be consistent with bash/Salt data format. But i alreeady said it was kneejerk impulse, so you eems to be crashing through door wide open.\r\n\r\n> The function is doing exactly what you are suggesting, keep data raw/verbatim/unescaped within OMV\r\n\r\nSome we are on the same page here. You blaze of ego is called for.\r\n\r\nSince eysterday i was asking you to show me at the se\r\nems between OMV and Salt, the exact borderleines, didn't i?\r\nI am glad you seem to did so above, https://github.com/openmediavault/openmediavault/issues/566#issuecomment-809529126\r\n\r\nAnd when i showed those links, i commented upon them.\r\n\r\n`Salt is based on Python, not PHP. The code you're ranting about never runs in the Salt context.`\r\n\r\nI never said so. Both Salt and OMV are \"black boxes\" with some data exchange. And i was asking you to point me to the raw places of exchange and raw data being exchanged, didn't i?\r\n\r\nYesterday i spent hours looking into Salt code and patching it along your suggestions.\r\nFirst i took your suggestions as correct and thought through. And just followed them. An then had to undo it all.\r\n\r\nNow you imply it was your time wasted not mine.\r\n\r\nThat `Example SLS:` - many times from yesterday i asked you how can i reproduice this activity from bash command line.\r\nFor example above - https://github.com/saltstack/salt/issues/54508#issuecomment-808875885\r\nYou kind of answered by showing PHP code for SLS generation - after many requests and hours.\r\nBut you still not answered how to trigger that action from bash.\r\n\r\nI asked you yesterday how to make OMV code trigger that action of Salt, allegedly buggy Salt.\r\nAnd you refused to help me doing it.\r\nhttps://github.com/openmediavault/openmediavault/issues/566#issuecomment-808955077\r\n\r\n```\r\nWhat can i patch in OMV5 to make this notification gone?\r\nWhy do you want to know that? What do you expect to improve?\r\n```\r\n\r\nYou made me look into Linux kernel i am not familiar with, at the same time you are not very willing to point me to specific OMV code and Salt commands you are familiar with.\r\n\r\nYou are blocking any attempt to debug OMV and Salt interaction - and you demand perfectly polished PRs. \r\nIt is not consistent. And it is would not help anyone. Not me, not you, not OMV users.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM12", "speaker": "the-Arioch", "conversation_id": "ROOT", "reply_to": "COM11", "timestamp": "2021-03-29T17:39:39Z", "text": "@garethgreenaway  @waynew  @sagetherage \r\n\r\nPlease consider this fix to `Salt` above\r\n\r\n> here is minimally patched /usr/lib/python3/dist-packages/salt/modules/mount.py\r\n> mount.py.gz\r\n\r\nhttps://github.com/saltstack/salt/issues/54508#issuecomment-808881089\r\n\r\nThat is a clear bug in `Salt` that can be reproduced on Linux box (and probably on other UNIX-likes) independently on OMV", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM13", "speaker": "votdev", "conversation_id": "ROOT", "reply_to": "COM12", "timestamp": "2021-03-29T19:38:29Z", "text": "@the-Arioch Please stop blaming and ranting me. This raised issue here has nothing to do with OMV.\n\n@garethgreenaway please set this issue to read-only, I had to do the same on the OMV issues to stop these rants.", "meta": {"posReactions": "0", "negReactions": "0"}}
