{"id": "ROOT", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2018-09-08T14:38:48Z", "text": "proposal: Go 2: error handling with functions and an error return? # Background (go 2 Process)\r \r go 2 has laid out the [problem of error handling](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md) (Please read before reading this proposal).\r \r I am told that alternative proposals should be raised as git issues here. Please add anyone else you think would like to join the discussion.\r \r \r # Introduction\r \r It is amazing to see the [error handling problem](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling-overview.md) being properly addressed. The [existing draft proposal](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md) is good, but I think we can iterate to make it better.\r To avoid confusion by comparison to the existing proposal, I will avoid mentioning it in this one.\r However, if you are a supporter of the existing proposal, please separately read my [critique](https://gist.github.com/gregwebs/cdaaaae475ae3012730694598a24e0b9) of it.\r \r It's useful to take a step back and clearly state what we are trying to do with our implementation:\r \r * provide an abstraction that allows for the insertion of a return statement for errors.\r * compose handler functions together before they are used with the error return\r \r In the existing go language, I cannot write a handler function which will create an early return from the function.\r There are a few approaches that use existing languages features for this control flow:\r * Macros (e.g. Rust originally used a `try!` macro).\r * Ruby supports anonymous functions that return from the enclosing function (method)\r * exceptions\r * Sequencing code with short-circuits. Some usage of monads in Haskell are a particularly good example of this.\r \r For sequences with short-circuits, see the errors are values post for how this can be done in go. However, this severely alters how one would write go code.\r \r \r # Proposal: handlers as functions, just a special check\r \r Lets repeat our goals again:\r \r * provide an abstraction that allows for the insertion of a return statement for errors.\r * compose handler functions together before they are used with the error return\r \r Composition can be handled with ordinary functions that take and return an error.\r \r That means we just need a mechanism to insert a `return`.\r For early return in my proposal, I will use a question mark operator `?` rather than a `check` keyword. This is for two reasons\r * the operator can be used postfix, which has readability advantages\r * the original draft proposal used `check`, but it functions differently, so this may help avoid confusion.\r \r See \"Appendix: Operator versus check function\" for a discussion on using `?` or a `check` keyword. \r \r \r ## Implementation as syntactic expansion\r \r ``` go\r v := f() ? handler\r ```\r expands to\r \r ``` go\r v, err := f()\r if err != nil {\r     return Zero, handler(err)\r }\r ```\r \r Where `handler` is a function that takes an `error` and returns one. `Zero` is the zero value for the (success) value returned before the error, assuming the function returns a single success value. A function that returns 4 values, the last one being an error, would have.\r \r ``` go\r     return Zero, Zero, Zero, handler(err)\r ```\r \r This is a simple, easy to understand transformation. It is easy to underestimate the value from being able to [understand the usage site without searching for context](https://github.com/golang/go/issues/27567#issuecomment-421204131). I am trying to avoid comparisons to other proposals, but I want to say that none of the others I have seen can be described this simply.\r \r All of the transformation is performed entirely by `?`. It inserts the nil check, the `return`, and creates the needed zero values. The handler is just a normal function and an argument to `?`.\r \r For some small convenience in writing cleanup handlers, the return section would actually expand to this:\r \r ``` go\r     return Zero, handler.ToModifyError()(err)\r ```\r \r See the section on handler types and the appendix section on `ThenErr` and `ToModifyError`.\r \r \r ## Basic example from the original proposal, re-written\r \r Putting this together, lets re-write SortContents, which wants different handlers in different places.\r \r ``` go\r func SortContents(w io.Writer, files []string) error {\r     handlerAny := func(err error) error {\r \treturn fmt.Errorf(\"process: %v\", err)\r     }\r \r     lines := []strings{}\r     for _, file := range files {\r \thandlerFiles := func(err error) error {\r \t    return fmt.Errorf(\"read %s: %v \", file, err)\r \t}\r \tscan := bufio.NewScanner(os.Open(file) ? handlerFiles)\r \tfor scan.Scan() {\r \t    lines = append(lines, scan.Text())\r \t}\r \tscan.Err() ? handlerFiles\r     }\r     sort.Strings(lines)\r     for _, line := range lines {\r \tio.WriteString(w, line) ? handlerAny\r     }\r }\r ```\r \r Let's show another example from the proposal (slightly simplified) that has handler composition:\r \r ``` go\r func process(user string, files chan string) (n int, err error) {\r     ahandler := func(err error) error { return fmt.Errorf(\"process: %v\", err) }\r     for i := 0; i < 3; i++ {\r \tbhandler := func(err error) error { return fmt.Errorf(\"attempt %d: %v\", i, err) }\r \tdo(something()) ? ahandler.ThenErr(bhandler)\r     }\r     do(somethingElse()) ? ahandler\r }\r ```\r \r It is possible to combine handlers in the same way one would combine functions:\r \r ``` go\r do(something()) ? ahandler.ThenErr(func(err error) error {\r \treturn fmt.Errorf(\"attempt %d: %v\", i, err) }\r )\r ```\r \r Or\r \r ``` go\r do(something()) ? func(err error) { return ahandler(bhandler(err)) }\r ```\r \r The example uses a `.ThenErr` method (see appendix) as a way to compose error handler functions together. \r \r \r ## Results\r \r * This alternative proposal introduces just one special construct, `?`\r * The programmer has control and flexibility in the error handling.\r * Handlers can be naturally composed as functions\r * The code is much more succinct and organized than current go error handling code.\r * errors can be returned from `defer`.\r \r \r ## Checking error returns from deferred calls\r \r This alternative proposal can support returning errors from `defer`:\r \r \tdefer w.Close() ? closeHandler\r \r \r \r ## Notes on error handler function types\r \r To respond to errors we want to do one of two things:\r * cleanup (side-effecting): `(error) -> nil` or `() -> nil`\r * modify the error: `(error) -> error`\r \r An error handler function must always have the type of the modifier, but we may not want the extra noise when writing a purely cleanup handler. The question mark operator can accept all forms. A cleanup function can be automatically converted to return the original error that would have been passed to it.\r \r This is also true of helpers that compose error functions such as `ThenErr`.\r See the Appendix section on `ThenErr` to see how this is implemented.\r \r \r # Appendix\r \r ## Appendix: Handle and anonymous function syntax\r \r This proposal is slightly more verbose than others that introduce a special anonymous function syntax that is lighter-weight and infers types.\r \r ``` go\r handle err { return fmt.Errorf(\"process: %v\", err) }\r ```\r \r Without this syntax, the proposal would read:\r \r ``` go\r handle func(err error) error { return fmt.Errorf(\"process: %v\", err) }\r ```\r \r I think it is worthwhile to explore having anonymous functions that are lighter-weight.\r However, I think this should be usable anywhere rather than just with a single keyword.\r \r But please leave this for another proposal rather than throw it in the mix with error handlers!\r \r \r ## Appendix: unary and binary.\r \r The question mark operator can be used as a unary to just return the exception without any handlers running.\r \r ``` go\r something()?\r ```\r \r This is equivalent to \r \r ``` go\r something() ? func(err error) error { return err }\r ```\r \r I am favoring writing the unary form without any spaces in this case (more similar to Rust), but we should use whatever syntax the community finds best.\r \r \r ## Appendix: Handling errors within the handler itself\r \r A cleanup handler may generate a new error that should be propagated in addition to the current error.\r I believe this should just be handled by a multi-error technique, e.g. [multierr](https://github.com/uber-go/multierr/blob/master/error.go).\r \r \r ## Appendix: custom error types\r \r The existing proposal seems like it would cast a concrete error type to the `error` interface when it is passed to a handler.\r I don't think this proposal is fundamentally different.\r I think this issue should be solved by the generics proposal.\r \r \r ## Appendix: ThenErr and ToModifyErr\r \r An implementation of ThenErr  and ToModifyErr. See the syntax expansion section for how the `?` operator uses `ToModifyError`.\r \r ``` go\r type Cleanup func(error)\r type CleanupNoError func()\r type ModifyError func(error) error\r \r type ToModifyError interface {\r \tToModifyError() ModifyError\r }\r \r func (fn1 ModifyError) ToModifyError() ModifyError {\r \treturn fn1\r }\r \r func (fn1 CleanupNoError) ToModifyError() ModifyError {\r \treturn func(err error) error {\r \t\tfn1()\r \t\treturn err\r \t}\r }\r \r func (fn1 Cleanup) ToModifyError() ModifyError {\r \treturn func(err error) error {\r \t\tfn1(err)\r \t\treturn err\r \t}\r }\r \r // Its easier to write this once as a function\r func CombineErrs(funcs ...ToModifyError) ModifyError {\r \treturn func(err error) error {\r \t\tfor _, fn := range funcs {\r \t\t\terr = fn.ToModifyError()(err)\r \t\t}\r \t\treturn err\r \t}\r }\r \r // But method syntax is convenient\r type ErrorHandlerChain interface {\r \tThenErr(ToModifyError) ModifyError\r }\r \r func (fn1 ModifyError) ThenErr(fn2 ToModifyError) ModifyError {\r \treturn func(err error) error {\r \t\treturn fn1(fn2.ToModifyError()(err))\r \t}\r }\r \r func (fn1 Cleanup) ThenErr(fn2 ToModifyError) ModifyError {\r \treturn func(err error) error {\r \t\tfn1(err)\r \t\treturn fn2.ToModifyError()(err)\r \t}\r }\r \r func (fn1 CleanupNoError) ThenErr(fn2 ToModifyError) ModifyError {\r \treturn func(err error) error {\r \t\tfn1()\r \t\treturn fn2.ToModifyError()(err)\r \t}\r }\r ```\r \r \r ## Appendix: Operator versus check function\r \r The original proposal [rejected the question mark](https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md#considered-ideas) and gave some reasons why.\r Some of those points are still valid with this proposal, and others are not.\r \r Here is [another proposal](https://gist.github.com/PeterRK/4f59579c1162cdbc28086f6b5f7b4fa2) that I believe advocates the same solution proposed in this alternative, but with a `check` function. I would be happy with that as a solution, but below I give my preference for `?`.\r \r The original proposal had just one argument given to `check`. This alternative favors the question mark in large part because there are now 2 arguments.\r The original proposal states that there is a large readability difference in these two variants:\r \r ``` go\r check io.Copy(w, check newReader(foo))\r io.Copy(w, newReader(foo)?)?\r ```\r \r However, I think this is a matter of personal preference. Once there is a left-hand-side assignment, the readability opinion may also change.\r \r ``` go\r copied := check io.Copy(w, check newReader(foo))\r copied := io.Copy(w, newReader(foo)?)?\r ```\r \r Now lets add in a handlers and check our preference again.\r \r ``` go\r copied := check(io.Copy(w, check(newReader(foo), ahandler), bhandler)\r copied := io.Copy(w, newReader(foo) ? ahandler) ? bhandler\r ```\r \r I believe `?` will be slightly nicer to use due to\r * fewer parantheses\r * putting error handling solely on the right-hand-side rather than both the left and right.\r \r Note that it is also possible to put all the error handling on the left-hand-side of the error source.\r \r ``` go\r copied := check(bhandler, io.Copy(w, check(ahandler, newReader(foo)))\r ```\r \r But I prefer keeping error handling on the right-hand-side for two reasons\r * a success result is still transferred to the left\r * it is possible to write an anonymous handler rather than being forced to declare it ahead of time\r \r \r ## Appendix: built-in result type\r \r A go programmer that has used Rust, Swift, Haskell, etc will be missing a real result type.\r I would like to see a go 2 proposal for discriminated unions which includes a result type.\r However, I think both the original proposal and this alternative proposal would work fine with the addition of a result type.\r This is because go effectively already has a result type when dealing with errors. It is a tuple where the last member is of type `error`.\r \r A future version of go with discriminated unions should be able to use `?` for dealing with a discriminated union result type.\r \r \r ## Appendix: intermediate bindings for readability\r \r Error handling on the right-hand-side may increase line length undesirably or seem to be easy to miss. Its always possible to use an intermediate binding.\r \r ```\r v, err := f(...) // could be a million lines long\r err ? handler\r ```\r \r ## Appendix: left-hand-side\r \r It is possible to support placing the handler on the left-hand-side.\r \r ```\r v := handler ? f(...)\r ```\r \r This could make more sense for `check`. One of the ideas behind this would be to emphasize the handler, for example in the case where `f(...)` is an enormous expression (see above section on intermediate bindings which is another way to handle this).\r \r ## Appendix: returning the zero value\r \r This proposal does not allow for the defensive practice of returning `-1` as the success value, along with the error. Where `-1` is useful because zero or a positive number are an allowed value in the problem domain, so someone may notice a `-1` propagating. I don't think we need to support this use case for a few reasons:\r \r   * It is not generally applicable anyways (consider a `uint`).\r   * The contract of using the function is already that errors must be checked before looking at success values.\r   * There are standard linters (errcheck) that will warn people about ignoring errors: we should instead ship this ability with `go vet`.\r \r \r ## Appendix: all proposal examples re-written\r \r Below are the rest of the code snippets shown in the original proposal, transformed to this alternative proposal.\r \r ``` go\r func TestFoo(t *testing.T) {\r \thandlerFatal := func(err error) { t.Fatal(err) }\r \tfor _, tc := range testCases {\r \t\tx := Foo(tc.a) ? handlerFatal\r \t\ty := Foo(tc.b) ? handlerFatal\r \t\tif x != y {\r \t\t\tt.Errorf(\"Foo(%v) != Foo(%v)\", tc.a, tc.b)\r \t\t}\r \t}\r }\r \r func printSum(a, b string) error {\r \thandler := func(err error) error { fmt.Errorf(\"printSum(%q + %q): %v\", a, b, err) }\r \tx := strconv.Atoi(a) ? handler\r \ty := strconv.Atoi(b) ? handler\r \tfmt.Println(\"result:\", x + y)\r \treturn nil\r }\r \r func printSum(a, b string) error {\r \tfmt.Println(\"result:\", strconv.Atoi(x)? + strconv.Atoi(y)?)\r \treturn nil\r }\r \r func CopyFile(src, dst string) error {\r \thandlerBase := func(err error) error {\r \t\treturn fmt.Errorf(\"copy %s %s: %v\", src, dst, err)\r \t}\r \r \tr := os.Open(src) ? handlerBase\r \tdefer r.Close()\r \r \tw := os.Create(dst) ? handlerbase\r \thandlerWithCleanup := handlerBase.ThenErr(func(err error) {\r \t\tw.Close()\r \t\tos.Remove(dst) // (only if a check fails)\r \t})\r \r \tcheck io.Copy(w, r) ? handlerWithCleanup\r \tcheck w.Close() ? handlerWithCleanup\r \treturn nil\r }\r \r \r func main() {\r \thandlerAll := func(err error) error {\r \t\tlog.Fatal(err)\r \t}\r \r \thex := check ioutil.ReadAll(os.Stdin) ? handlerAll\r \tdata := check parseHexdump(string(hex)) ? handlerAll\r \tos.Stdout.Write(data)\r }\r ```", "meta": {"posReactions": "3", "negReactions": "2"}}
{"id": "COM0", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2018-09-08T16:11:25Z", "text": "Operator ? looks less noticeable than \"check\".", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2018-09-09T00:02:05Z", "text": "@PeterRK you might want to state whether that is a good or a bad thing! I am assuming it is a critique.\r\n\r\nOne advantage of this proposal is that it is not breaking any new ground, but instead following the lead of Rust (but adding a handler component). So we could survey Rust users to see if noticeably of `?` is a problem.\r\n\r\nAlthough I have a preference for `?`, I want to note that I would be perfectly happy with this proposal being accepted but modified to use `check` instead.\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM2", "speaker": "networkimprov", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2018-09-09T00:09:27Z", "text": "https://go.googlesource.com/proposal/+/master/design/go2draft-error-handling.md#considered-ideas", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM3", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2018-09-09T01:06:39Z", "text": "@gregwebs You are right. Less noticeable may be an advantage.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM4", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2018-09-09T04:45:24Z", "text": "@networkimprov you are right I should explicitly talk about how the question mark was mentioned in \"considered ideas\". In that, the case is made for `check` rather than `?`. \r\nSome of those points are still valid with this proposal, and others are not. This is reviewed in the section \"Appendix: Operator versus check function\".\r\n\r\nI hope we can move the conversation from comparing `?` to `check` (either of which are acceptable to me) to the bigger picture of using regular functions instead of special stacking.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM5", "speaker": "networkimprov", "conversation_id": "ROOT", "reply_to": "COM4", "timestamp": "2018-09-09T06:09:47Z", "text": "There is no doubt in my mind that the next proposal draft from the Go team will add named handlers (or a func type) and drop implicit handler chains, given the feedback to date. It might drop `check` altogether.\r\n\r\nHowever, that isn't enough IMO. My detailed critique: [Golang, how dare you handle my checks!](https://medium.com/@mnmnotmail/golang-how-dare-you-handle-my-checks-d5485f991289)", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM6", "speaker": "deanveloper", "conversation_id": "ROOT", "reply_to": "COM5", "timestamp": "2018-09-09T06:35:22Z", "text": "I'll say this a million times - I hate exiting from a function without a return. This should _never_ happen unless there is a catastrophic error (panic). Also, returning an error without adding on to the context should be discouraged. The unary `?` is just a bad idea for Go in general. (Both returning implicitly AND not adding context to the error)\r\n\r\nThe rest of the proposal is interesting, but I'm not sure how much I like the idea of the `?`. I think it means too many things in too many different languages, and it would add to the confusion. (Conditional operator (C), null-safe operation (Kotlin), Coallessing (C#), etc).\r\n\r\nI also feel like the built-in `check` function approach _feels_ more like Go. I like that better than the `?`. You guys discussed it being \"less noticable\" which is \"good\", but I'd say the opposite. It's the potential exit to a function, it _needs_ to be noticable to be maintainable.\r\n\r\nUsing `check(...)` instead of `?` also resolves your \"should we allow `break` and `continue` as the RHS? The answer: no.\r\n\r\nEither way, this shouldn't be about syntax, syntax can be rethought. Let's discuss the idea behind it.\r\n\r\nI think having different function signatures doing different things is an interesting idea, but I don't like it. I think it makes reading code confusing, especially at the call site (\"check site\"?) of the handler function. If I'm reading someone else's code, I don't want to have to scroll back up to the top of the function to see if my code continues or not. The nice thing about the `handle/check` construct is that you _know_ that _if the error is not nil, the function exits_.\r\n\r\nI do like this idea though. Those are my critiques, I like the rest of the proposal. The use of anonymous functions rather than handler blocks is a good idea in my book.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM7", "speaker": "deanveloper", "conversation_id": "ROOT", "reply_to": "COM6", "timestamp": "2018-09-09T06:44:19Z", "text": "To expand on the whole function signature thing, here's what I mean:\r\n\r\n```go\r\nfunc errorProne() error {\r\n    handler := func(err error) {\r\n        fmt.Println(\"unimportant error occurred:\", err)\r\n    }\r\n\r\n    // 50 lines later\r\n\r\n    // My internal monologue:\r\n    // \"Does this function exit if there's an error,\r\n    // or does it continue execution?\"\r\n    f := check(os.Create(\"Foo\"), handler)\r\n}\r\n```\r\n\r\nAgain, in the `check/handle` made it clear: `if err != nil, the function will exit`", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM8", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "COM7", "timestamp": "2018-09-09T07:38:07Z", "text": "Error handling is a potential control flow changing point, so we care about it.\r\n\r\nThe design in original draft introduces a new control flow changing rule, what we call \"special stacking\" or \"chained handler\". That brings confusion more than convenience.\r\n\r\nSome guys, include me, suggest to use a new control flow changing mark with normal function as error handler. However, how to implement this mark is controversial.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM9", "speaker": "networkimprov", "conversation_id": "ROOT", "reply_to": "COM8", "timestamp": "2018-09-09T08:14:32Z", "text": "A named catch block after check/?/etc does the trick nicely :-)\r\n```\r\n?outer f1() // or more Go-like: #outer = f()\r\nfor ... {\r\n   ?inner f2()\r\n   catch inner { ?outer fmt.Errorf(\"loop %v\", inner) } // no return\r\n}\r\ncatch outer { return fmt.Errorf(\"context %v\", outer) }\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM10", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "COM9", "timestamp": "2018-09-09T08:51:50Z", "text": "@deanveloper I agree with that `if err != nil, the function will exit`. I believe exit on error is the common case. We should focus on the common case. If needing continue, just handle it with old style.\r\n\r\n@networkimprov @gregwebs  I know you guys want to figure out a solution covering all cases. I hope it will be a lightweight one. I think heavy solution is against the philosophy of GO. And the design in original draft is already too heavy to me. ", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM11", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "COM10", "timestamp": "2018-09-09T09:38:13Z", "text": "Error handling consists of handler and trigger.\r\nLet me ask some questions.\r\n\r\n1) Should trigger be bound with one or more handlers explicitly?\r\nIn the original draft, \"check\" is the trigger. It cannot be bound with any handler explicitly. So a matching rule is needed.\r\n\r\n2) Should handler be special or just a normal function?\r\n\r\n3) Should trigger be a filter or just a consumer?\r\n In the original draft, \"check\" is the filter. It take return values from child function, and filters out the error. But in code `_, #err := function()`, the trigger `#err` is just a consumer.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM12", "speaker": "networkimprov", "conversation_id": "ROOT", "reply_to": "COM11", "timestamp": "2018-09-09T10:06:23Z", "text": "In #27519 (#id/catch model), `#err = f()` filters for non-zero, as stated.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM13", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "COM12", "timestamp": "2018-09-09T10:19:35Z", "text": "@networkimprov I mean that filter can work with pipe.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM14", "speaker": "networkimprov", "conversation_id": "ROOT", "reply_to": "COM13", "timestamp": "2018-09-09T11:27:37Z", "text": "See link I posted above re \"critique\" for perspective on nesting calls that return error. (A \"pipe\" is an IPC or stream mechanism btw.)", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM15", "speaker": "PeterRK", "conversation_id": "ROOT", "reply_to": "COM14", "timestamp": "2018-09-09T11:47:56Z", "text": "Good luck! @networkimprov ", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM16", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM15", "timestamp": "2018-09-09T14:20:17Z", "text": "@deanveloper it seems you have misread the proposal. Perhaps I wrote too much, let me know how I can make the section on handler function types more clear. Currently it does state:\r\n\"A cleanup function will automatically be converted to return the original error that would have been passed to it.\"\r\n\r\nIf you write\r\n\r\n``` go\r\n    handler := func(err error) {\r\n        fmt.Println(\"unimportant error occurred:\", err)\r\n    }\r\n```\r\n\r\nWhen used as a handler, the error will still be passed along (see the section on `ThenErr` to show how this can be accomplished).\r\n\r\nIn this proposal, the usage of `check` or `?` always means that the function returns immediately if the error is not nil.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM17", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM16", "timestamp": "2018-09-09T14:53:54Z", "text": "@deanveloper thanks for critiquing adding `break/continue`. I removed that section now because I don't like the idea either and it seems to distract from the proposal rather than to clarify.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM18", "speaker": "deanveloper", "conversation_id": "ROOT", "reply_to": "COM17", "timestamp": "2018-09-09T15:12:46Z", "text": "Ah, I see. You are correct I did misread it, although now there's no explicit exit to the function. (See how that can get confusing to a reader? The function doesn't mark an exit, so I didn't think there was one)\r\n\r\nAnyway, there shouldn't be a special case to allow a developer to return the error which occurred without additional context. If they want to do that, they should do it explicitly with `return err`\r\n\r\nAlso, assuming you want to return the zero value for the other numbers is a dangerous game. For instance, let's say I wanted to write the following function:\r\n\r\n```go\r\n// Returns how many occurrences of find exist in the UTF8 encoded reader r\r\nfunc CountOccurences(r io.Reader, find string) (n int, err error)\r\n```\r\n\r\nIf an error occurs, I don't want to return `n=0` because 0 is a valid return value of my function, I'd want to return `n=-1`.\r\n\r\n`check/handle` does this well because the `return` in it's system actually returns to the function, so there's no assumptions about what you're trying to return.\r\n\r\nPerhaps the handler should always be in the form `(error) -> (parent function's return values)`. This kind-of destroys the idea of reusable handler generators (`ThenErr`), though.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM19", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM18", "timestamp": "2018-09-09T15:19:17Z", "text": "@bmeh (or anyone else that comes along), it would be great if you left your reason for the thumbs down.  The proposal has received a lot of useful critiques around the edge cases of language interaction. \r\nBut I actually have not yet seen a single critique of the core idea of this proposal, including outside this go 2 process where I have shown it to others.\r\n\r\n@networkimprov similarly, it would be great to see critical comments of the core idea here and leave promotions of your proposal on the github issue that is already open for that.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM20", "speaker": "networkimprov", "conversation_id": "ROOT", "reply_to": "COM19", "timestamp": "2018-09-09T18:15:21Z", "text": "I posted a link to a pure critique of check/handle, which largely applies to this proposal. It does not mention #id/catch. I urge you to read it.\r\n\r\nI mentioned a catch block here as a solution to the control flow issue raised above, and used a prefix variation of your `? handler` syntax with it.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM21", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM20", "timestamp": "2018-09-09T21:51:12Z", "text": "@deanveloper zero values: thanks for bringing that up. This proposal is essentially for discriminated unions. That is, the non-error value should not exist. I know that use cases do exist for actually returning a tuple of two meaningful values. However, I believe they are rare enough (I have seen thousands of lines of go code that never do this) that it is a mistake to place them as a design constraint on an error handling system. One can still use one of two approaches:\r\n\r\n* use the existing style of error handling\r\n* use an error type that gives back the value you want\r\n\r\nThe latter looks something like this:\r\n\r\n``` go\r\ntype CountOccurencesError struct {\r\n    Count int\r\n    Err error\r\n}\r\nfunc (e CountOccurencesError) Error() string { return e.Err.Error() }\r\n\r\n// Returns how many occurrences of find exist in the UTF8 encoded reader r\r\nfunc CountOccurences(r io.Reader, find string) (n int, err CountOccurencesError)\r\n```\r\n\r\nI believe you do need generics to be able to return the concrete type through an error check.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM22", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM21", "timestamp": "2018-09-09T21:58:40Z", "text": "@deanveloper no unary form of the check: I would be okay with always requiring an error handler that adds context. But I thought always requiring a handler was probably too heavy-handed for a go community that is not already consistently doing that.\r\n\r\nIf you define a function `identity`, then you just have to write `? identity` if you don't want to add anything to an error. So keep in mind it is easy to subvert the intent.\r\n\r\nAn additional consideration is that some users may be satisfied enough by using stack traces that they don't feel the need to add context in every passing of an error.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM23", "speaker": "deanveloper", "conversation_id": "ROOT", "reply_to": "COM22", "timestamp": "2018-09-09T22:02:03Z", "text": "That's not what I'm trying to say here - what I'm saying is that the zero-value of `int` is meaningful in the `CountOccurences` function, so I would much rather return a `-1` to make it clear that the function doesn't return meaningful information if an error occurs.\r\n\r\nI want to be clear. I don't want the caller to see `0, err`, as it could be mistaken for \"zero occurrences were found before finding the following error\", I want them to see values from the function indicating that the function does not return useful information (other than the error) if an error occurs, which can be done by returning `-1, err`.\r\n\r\nMost of the time `0, err` works, but in my experience, returning `-1, err` is not an uncommon case", "meta": {"posReactions": "2", "negReactions": "0"}}
{"id": "COM24", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM23", "timestamp": "2018-09-09T22:40:36Z", "text": "@deanveloper sorry for missing your actual concern. I think your level of programming defensiveness is probably appropriate given the lack of discriminated unions in go and the prevalence of zero values. However, it seems not generally applicable (what if I have a `uint`?) and unnecessary. The contract is always that the caller must check the error value before looking at the success value. We shouldn't weaken this proposal because someone is going to ignore errors. There are linters that check for this (errcheck): it would be much more powerful to add that capability to `go vet` or otherwise have this statically checked.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM25", "speaker": "Azareal", "conversation_id": "ROOT", "reply_to": "COM24", "timestamp": "2018-09-10T01:37:02Z", "text": "I personally think that handle is sugar for goto rather than an anonymous function.\r\n\r\nIt seems to be doing this:\r\n```go\r\nfunc something() {\r\n    var __reservedVar error\r\n    {\r\n    errHandle:\r\n        return __reservedVar\r\n    }\r\n    blah, err := x()\r\n    if err != nil {\r\n        __reservedVar = err\r\n        goto errHandle\r\n        return\r\n    }\r\n}\r\n```\r\naka\r\n```go\r\nfunc something() {\r\n    handle err {\r\n        return err\r\n    }\r\n    blah := check x()\r\n}\r\n```\r\nIf you read it like that, the return makes perfect sense. Simplified example.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM26", "speaker": "deanveloper", "conversation_id": "ROOT", "reply_to": "COM25", "timestamp": "2018-09-10T03:51:23Z", "text": "> The contract is always that the caller must check the error value before looking at the success value\r\n\r\nThis is a very fair point. Although I think that `-1` is still a pretty common thing to return when an error occurs.\r\n\r\nI've said this before, I really like the proposal. It feels very Go-like (at least when using a `check` built-in function), which is hard to come by for proposals not from the Go team themselves.\r\n\r\nI added a +1. Sorry if it seems like I'm nitpicking it pretty hard, just want to make sure everything is considered, this is a really good proposal\r\n\r\n> I personally think that handle is sugar for goto rather than an anonymous function.\r\n\r\nYeah I was the same way. I saw `handle` as more of a goto than a function.\r\n\r\nAlthough both views work and I can see it going both ways. I think it personally makes more sense as a goto (it's how it probably works under the hood, AND just works better in general when it comes to how it returns).", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM27", "speaker": "gregwebs", "conversation_id": "ROOT", "reply_to": "COM26", "timestamp": "2018-09-13T19:10:34Z", "text": "@deanveloper thanks for the :+1: thorough review, and the good questions!\r\nAlso, please help me promote usage of `errcheck`/`gosec` so that we don't have to bend over backwards with defensive coding practices!\r\n\r\n@ianlancetaylor is there a process to moving this proposal forward with more reviews?", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM28", "speaker": "ianlancetaylor", "conversation_id": "ROOT", "reply_to": "COM27", "timestamp": "2018-09-13T19:28:45Z", "text": "There is a relatively slow moving Go2 proposal review process.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM29", "speaker": "ianlancetaylor", "conversation_id": "ROOT", "reply_to": "COM28", "timestamp": "2018-09-13T19:29:35Z", "text": "Let me expand on that to say that nothing is going to happen in a hurry.  We're going to take the time required to make changes that seem good.", "meta": {"posReactions": "0", "negReactions": "0"}}
