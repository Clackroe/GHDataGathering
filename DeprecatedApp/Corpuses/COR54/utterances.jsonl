{"id": "ROOT", "speaker": "FoxSamu", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2020-11-05T14:39:17Z", "text": "Add annotation-based tools for dist-based implementation of methods Today I ran into the annoying coding style issue that you have to create a complete new class just for calling a client-only method if available. Because this makes code very very ugly I created a different approach:\r \r A new `@ImplementOn` annotation can specify a method in the same class to be overwritten by another method when on a specific `Dist`. For example:\r \r ```java\r     public void myMethod() {\r \r     }\r \r     @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r     private void myMethod_client() {\r         System.out.println(\"Client implementation\");\r     }\r \r     @ImplementOn(dist = Dist.DEDICATED_SERVER, method = \"myMethod\")\r     private void myMethod_server() {\r         System.out.println(\"Server implementation\");\r     }\r ```\r \r Then, upon loading of this class, an ASM transformer (`net.minecraftforge.common.asm.RuntimeDistImplementor` to be precise) injects either `myMethod_client` or `myMethod_server` into the method `myMethod` and strips unused `@ImplementOn` methods so that they won't get loaded. The above example will, on `Dist.CLIENT` become:\r \r ```java\r     public void myMethod() {\r         this.myMethod_client();\r     }\r \r     @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r     private void myMethod_client() {\r         System.out.println(\"Client implementation\");\r     }\r ```\r \r Note how the method is directly delegated: this keeps line numbers and debug info understandable in stack traces. The system works for methods with or without return values, static and virtual methods, and any set of arguments. For `@ImplementOn` to work properly, the following conditions are checked, with the intentions specified:\r \r - The return types of the target method and the injected method must match **exactly**. This is because it finds the target method based on the name specified and the descriptor (including return type) of the injector method.\r - The argument lists of the target method and the injected method must match **exactly**. This is because it finds the target method based on the name specified and the descriptor of the injector method.\r - The `static` modifier must either be specified on both the target and injected method, or must be omitted on both methods. When one is static and the other isn't, the injection fails. This is because a static method can not reference an instance method. An instance method can access a static method but for the semantics of 'replacing the method' I forced the `static` modifiers to match exactly.\r - The injected method **must** be private. This prevents overriding which can cause strange issues as unused injected methods are stripped (subclasses might be unable to load if they call `super`). This also prevents them being called from within another class (even inner classes can't call them - this goes via a bridge method).\r - The injected method may never be called (only checked in a development environment, since it checks all instructions in a class and might drop performance a lot). This filters the cases where a method of the same class accesses the injector (including bridge methods), which must not happen either.\r - There must be, for each separate `Dist`, only one injected method: you can specify injections for the same method but for different dists. This rule is obvious: you should not inject into a method twice because you will then overwrite your own injection.\r \r Note that this works with method overloading: an `@ImplementOn` annotated method will be injected into the method with the name specified in the annotation's `method` parameter and the descriptor of the injected method. Hence this will work:\r \r ```java\r     public void myMethod() {\r         System.out.println(\"Common implementation\");\r     }\r \r     @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r     private void myMethod_client() {\r         System.out.println(\"Client implementation\");\r     }\r \r     public void myMethod(int argument) {\r         System.out.println(\"Common implementation, argument = \" + argument);\r     }\r \r     @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r     private void myMethod_client(int argument) {\r         System.out.println(\"Client implementation, argument = \" + argument);\r     }\r ```\r \r What's also notable here is that an `@ImplementOn` method is only injected when the `dist` parameter matches the `Dist` of the environment. When the `Dist`s don't match, the target method is left untouched and the injected method is stripped from the class, if the `Dist`s _do_ match, the contents of the target method are stripped **completely** and are overwritten by the necessary bytecode.\r \r ---\r \r As an alternative suggestion to the semantics I've implemented in the current pull request, it's also possible to make a `@DelegateOn` annotation which is put above the target method and using the `@OnlyIn` annotations for stripping sided methods. It would then look like this:\r \r ```java\r     @DelegateOn(client = \"myMethod_client\", server = \"myMethod_server\")\r     public void myMethod() {\r \r     }\r \r     @OnlyIn(Dist.CLIENT)\r     private void myMethod_client() {\r         System.out.println(\"Client implementation\");\r     }\r \r     @OnlyIn(Dist.DEDICATED_SERVER)\r     private void myMethod_server() {\r         System.out.println(\"Server implementation\");\r     }\r ```\r \r Drawback is here: the `myMethod_client` and `myMethod_server` render as unused and don't have an annotation indicating they are dynamically being injected, nor is there any visual reason not to call them.\r \r ---\r \r I think this is a well-working alternative to `DistExecutor.safeCallWhenOn`, since it doesn't require the targeted method to be in a separate class, it allows the use of arguments and it works with return types.\r \r ---\r \r Things that might still be necessary and which are missing now:\r \r - Checking the signatures of the methods (so that generic types and `throws` clauses do match). This is only a semantical issue though, in bytecode it's perfectly safe if a checked exception is thrown without having it in the `throws` clause and due to type erasure generics will work.", "meta": {"posReactions": "2", "negReactions": "3"}}
{"id": "COM0", "speaker": "diesieben07", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2020-11-05T15:23:25Z", "text": "I don't think we should be adding more ASM based hackyness because you are too lazy to write a separate class.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "TheCurle", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2020-11-05T15:26:53Z", "text": "I concur. Sided safe referencing is a Java pattern, and it is generally encouraged to separate code that will be used to build two different releases of the same program. In this case, client and server of a game.\r\n\r\nYour solution is no better than just using OnlyIn, which is known to break a lot of things: see #7440. ", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM2", "speaker": "FoxSamu", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2020-11-05T15:42:29Z", "text": "Closed by the dictators who made `@Mod`, `@Mod.EventBusSubscriber`, `@SubscribeEvent`, `@OnlyIn`, `IExtensibleEnum`, ... neither are they java patterns in this case", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM3", "speaker": "TheCurle", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2020-11-05T15:44:43Z", "text": "Welcome to hacking into a game that was never built to support mods. \r\nOnlyIn exists only to support vanilla, for the record.\r\nSubscribeEvent is superceded recently by DeferredRegister, and your argument is overall invalid.\r\n\r\nAlso, yes, it is a pattern. This is standard procedure...", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM4", "speaker": "gigaherz", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2020-11-05T15:53:06Z", "text": "A few things:\r\n* OnlyIn is used to mark vanilla methods that are missing, it doesn't cause them to be missing. The OnlyIn transformer is a hack, and only exists for specific exceptional situations, it's not a convenience and will never be endorsed as one.\r\n* `@Mod` and `@SubscribeEvent` are API markers, they are used to identify features, it's very much not the same as what you are proposing.\r\n* IExtensibleEnum isn't an annotation? It's a hack needed by modders.\r\n\r\nTo use client-only code correctly you just need, at most, one (1) helper class, which has some forwarders and keeps all client-only references all hidden from the shared logic. You just need to follow two simple rules:\r\n1. This helper class shouldn't have any outward references to the client-only code (no client-only extends/implement, params or fields)\r\n2. The methods in this class should avoid \"implicit casts\" (eg, assigning Minecraft#player to a PlayerEntity variable), which cause the jvm to have to classload the types so it can verify they are compatible.\r\n\r\nThat's all. One class and some basic defensive coding.", "meta": {"posReactions": "0", "negReactions": "0"}}
