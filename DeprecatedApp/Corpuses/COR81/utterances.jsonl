{"id": "ROOT", "speaker": "jhkrischel", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2017-06-28T16:50:58Z", "text": "Allow decrypting of files with vaulted variables ##### ISSUE TYPE\r  - Feature Idea\r \r ##### COMPONENT NAME\r ansible-vault\r \r ##### ANSIBLE VERSION\r ```\r ansible 2.3.1.0\r   config file = \r   configured module search path = Default w/o overrides\r   python version = 2.7.13 (default, Apr 23 2017, 16:50:35) [GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)]\r ```\r \r ##### CONFIGURATION\r n/a\r \r ##### OS / ENVIRONMENT\r n/a\r \r ##### SUMMARY\r ansible-vault decrypt allows the decryption of completely encrypted yaml files, but it will not decrypt vaulted variables in an unencrypted yaml file with encrypted variables.\r \r It would be nice, for CLI purposes, to have decrypt take a partially encrypted file, and give us the decrypted text.\r \r ##### STEPS TO REPRODUCE\r * create `test.yml` file with single encrypted variable encrypted by `~/.vault_pass.txt`\r * ansible-vault decrypt file\r \r ```\r ansible-vault decrypt test.yml --vault-password-file ~/.vault_pass.txt\r ```\r \r ##### EXPECTED RESULTS\r * Expected plain text output with encrypted variable decrypted.\r \r ##### ACTUAL RESULTS\r ```\r ERROR! input is not vault encrypted data for test.yml\r ```\r ", "meta": {"posReactions": "100", "negReactions": "0"}}
{"id": "COM0", "speaker": "gundalow", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2017-06-29T08:55:23Z", "text": "@alikins I believe you look after vault", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "krzysztof-magosa", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2017-07-06T19:14:57Z", "text": "Would be also good if 'ansible-vault view' worked for such files.", "meta": {"posReactions": "22", "negReactions": "0"}}
{"id": "COM2", "speaker": "alikins", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2017-07-24T14:53:42Z", "text": "This might be something that will get covered in https://github.com/ansible/ansible/blob/devel/docs/docsite/rst/roadmap/ROADMAP_2_4.rst#id25\r\n\r\nAs a user, what would you expect the decrypted file to look like?\r\n\r\nFirst thought is just to replace the !vault yaml scalar with the decrypted text. That probably makes the most sense for 'view'.\r\n\r\nFor 'decrypt' and especially 'edit', I'm not sure that will be sufficient. For 'edit', the re-encrypt phrase is going to need to be able to figure out which variable values originally came from a vaulted value. Especially if the file is edited significantly (reordering lines for example, or changing the variable name). \r\n\r\nSo the file presented for editing would need to include some markers indicating the text that was decrypted/should be re-encrypted. A couple of ways to do that:\r\n\r\n   1) Add comments to mark the text, and doing some text manipulation/regexes to replace it with encrypted text in place. Something like:\r\n\r\n``` yaml\r\n# START VAULT PLAINTEXT - my_var\r\nmy_var: my text goes here\r\n# END VAULT PLAINTEXT - my_var\r\nsome_plain_var: blippy\r\n```\r\n\r\n  2) Add a new yaml type indicating text to be encrypted. Something like:\r\n\r\n``` yaml\r\nmy_var: !vault-plaintext |\r\n    my text goes here\r\nsome_plain_var: blippy\r\n```\r\n\r\nIt would be best if we could yaml parse the input, decrypt the value, serialize the yaml to a file for editing, let user edit it, then yaml parse the results, encrypt the value, and serialize to yaml and save.\r\n\r\nBut... doing that with the available yaml parser would lose comments and ordering of maps.\r\n\r\nSo likely some in place string/text manipulations will be required.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM3", "speaker": "alikins", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2017-09-14T14:14:22Z", "text": "Not going to happen for 2.4, so bumped to 2.5.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM4", "speaker": "ansibot", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2018-01-31T15:47:45Z", "text": "@jhkrischel This issue is waiting for your response. Please respond or the issue will be closed.\n\n[click here for bot help](https://github.com/ansible/ansibullbot/blob/master/ISSUE_HELP.md)\n<!--- boilerplate: needs_info_base --->", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM5", "speaker": "andrunah", "conversation_id": "ROOT", "reply_to": "COM4", "timestamp": "2018-01-31T18:57:34Z", "text": "Any news when this is planned to be implemented in ansible?\r\nWe have lots of passwords as vaulted variables, hence updating\\viewing them is troublesome.\r\nI did some script (based on solution, from alikins last post) to at least parse such yml and decrypt every variable to stdout\\file to see a decrypted file at once, but this is just a script that is not a complete solution (and it is decrypting only).\r\nUPD: I ended up going thru ansible code to understand how it works with encrypted variables and wrote some tiny script that I can use in my automation jobs with Jenkins. I hope it would be useful for anyone who is waiting for this issue to be fixed.\r\nhttps://github.com/andrunah/ansible-vault-variable-updater\r\nIt would be nice to have this functionality in ansible out of the box.", "meta": {"posReactions": "13", "negReactions": "0"}}
{"id": "COM6", "speaker": "csillab", "conversation_id": "ROOT", "reply_to": "COM5", "timestamp": "2018-03-05T14:27:09Z", "text": "I do see this in 2.5.\r\n\r\n```\r\nroot@ubuntu-xenial:~# ansible  --version\r\nansible 2.5.0rc1 (stable-2.5 36566e62a7) last updated 2018/03/05 13:46:00 (GMT +000)\r\n  config file = /etc/ansible/ansible.cfg\r\n  configured module search path = [u'/root/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']\r\n  ansible python module location = /root/git/ansible/lib/ansible\r\n  executable location = /root/git/ansible/bin/ansible\r\n  python version = 2.7.12 (default, Nov 20 2017, 18:23:56) [GCC 5.4.0 20160609]\r\n\r\nroot@ubuntu-xenial:~# cat vars.yaml\r\nansible_ssh_pass: !vault |\r\n          $ANSIBLE_VAULT;1.2;AES256;my_user\r\n          31313064366365626535323066613234626234336664333266663161366233396365633063303539\r\n          3066363333666236666335656631666663373037643338630a303763363031373337663733326134\r\n          38336566366535373561373830386638663635363438333633313536333731646331366138383961\r\n          3331346163623661340a663862323337313562376338386539326438323562383136383832376266\r\n          31306663393532323761353761353435373432633632626365633734303335633436\r\nnonpass: pass\r\nroot@ubuntu-xenial:~# ansible-vault view vars.yaml\r\nVault password:\r\nERROR! input is not vault encrypted datavars.yaml is not a vault encrypted file for vars.yaml\r\n```", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM7", "speaker": "ansibot", "conversation_id": "ROOT", "reply_to": "COM6", "timestamp": "2018-03-05T14:37:12Z", "text": "@jhkrischel This issue is waiting for your response. Please respond or the issue will be closed.\n\n[click here for bot help](https://github.com/ansible/ansibullbot/blob/master/ISSUE_HELP.md)\n<!--- boilerplate: needs_info_base --->", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM8", "speaker": "alikins", "conversation_id": "ROOT", "reply_to": "COM7", "timestamp": "2018-03-09T18:13:35Z", "text": "I poked at this a little yesterday and braindumped some thoughts in code comments at https://github.com/alikins/ansible/commit/603cac4a041a10ec8186617c95ef539a9ece787a\r\n\r\n(copied/paraphrased here for discussion)\r\n\r\n>         Open a file, figure out if it is all vault or yaml with vault strings, edit.\r\n> \r\n>         if yaml with vault strings, parse the yaml with AnsibleYaml \r\n>         and secret. Replace with '!vault-plaintext vault-id' and plaintext. \r\n>         Save, open editor. \r\n>         On save/reencrypt, reparse the file with AnsibleYaml, get the\r\n>         plaintext of the to be reencrypted vaulted string, encrypt it\r\n>         (!vault-plaintext -> !vault,\r\n>          AnsibleVaultUnencryptedUnicode -> AnsibleVaultEncryptedUnicode).\r\n> \r\n>         And then, things get complicated... we can't just AnsibleYaml.dumps()\r\n>        the data structure out:\r\n>             1. Comments and comment placement is not preserved which \r\n>                 is kind of annoying\r\n>             2. AnsibleYaml can loads things into data structures\r\n>                 that it can not `dumps()` out.\r\n>                 Ie, we can't serialize a bunch of stuff we can deserialize.\r\n> \r\n>             So just AnsibleYaml.dumps'ing the datastructure back\r\n>             to a file will usually either fail or do the wrong thing.\r\n> \r\n>             #2 above is unlikely to get fixed soon if ever.\r\n>             #1 is mostly a limitiation of the PyYaml yaml module ansible uses. \r\n>                Other implementation like Rueyaml can do this, but it is unlikely for \r\n>                ansible to change this any time soon.\r\n> \r\n>         So, since we can't just serialize to yaml, we likely need to do some \r\n>         string manipulation to replace the '!vault ' blob.\r\n> \r\n>         We would need to know exactly what the before string looked like\r\n>         and where in the file it is, and what the new !vault will look like.\r\n>         But we don't really know what the new  !vault-plaintext \r\n>         string will look like.\r\n> \r\n>         For that  matter, we don't know if it will be in the same place,\r\n>         or if it will exist at all, or if it will be at the same path in the \r\n>         datastructure after the edit. \r\n> \r\n>         We could limit edit to only try to work in cases where\r\n>         those aren't changed. We also have no idea what the\r\n>         plaintext will look like.\r\n>         \r\n>        ideas:\r\n>            - !vault-plaintext is a compound yaml type, with fields for\r\n>               the vault id to use, and for the plaintext. Could also\r\n>              possibly include some identifying info for what the !vault\r\n>              it replaced looked like. An example:\r\n> \r\n>         some_var: !vault-plaintext:\r\n>                     vault_id: 'dev'\r\n>                     decrypted_from: |\r\n>                                     $ANSIBLE_VAULT;1.1;AES256\r\n>                                     66393964663765613335633461643334393234346231666665306635323635333137306339356232\r\n>                     plaintext: |\r\n>                                 The new plaintext to replace decrypted_from with\r\n> \r\n>         That would give vault-edit enough info to do a reliable job \r\n>         of replacing the previous content.\r\n> \r\n\r\n       \r\n\r\nThe downside to that approach is that it points out the limitations of the current !vault format. It may also be useful to extend !vault to support getting a data structure with info in it instead of just the plain text scalar. At the moment, I'm not sure if it could do both but it seems possible.\r\n\r\nOr could just call the extended info version of !vault  !vault-extended or similar.  At that point it might be possible to make !vault-extended the default vault blob format for vaulted files as well. ie, instead of\r\na vaulted file being:\r\n\r\n```\r\n$ANSIBLE_VAULT;1.1;AES256\r\n66393964663765613335633461643334393234346231666665306635323635333137306339356232\r\n3533306631646431663239623762366365663137383435380a393139303161383561303336623962\r\n35373663663036333863373666326634616532376335333133326163376136353636633763623739\r\n3736343064326662390a306438356239386665306437646665323836393032393565666136643362\r\n3663\r\n```\r\n\r\nIt would be yaml something like\r\n\r\n``` yaml\r\n--- \r\n- !vault-extended:\r\n    vault_id: 'dev'\r\n    cipher: AES256\r\n    encrypted_on: 2018-03-14\r\n    ciphertext: |\r\n        $ANSIBLE_VAULT;1.2;AES256;dev\r\n        66393964663765613335633461643334393234346231666665306635323635333137306339356232\r\n                  \r\n```\r\n\r\nie, more or less like https://github.com/voxpupuli/hiera-eyaml", "meta": {"posReactions": "2", "negReactions": "0"}}
{"id": "COM9", "speaker": "gail-b-stewart", "conversation_id": "ROOT", "reply_to": "COM8", "timestamp": "2018-03-14T14:39:50Z", "text": "Would it be possible for the user to tell you which scalars to decrypt - not try to do the whole file?", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM10", "speaker": "MarkusTeufelberger", "conversation_id": "ROOT", "reply_to": "COM9", "timestamp": "2018-04-12T14:21:15Z", "text": "Right now the usability of encrypted variables compared to whole encrypted files is rather poor unfortunately. Especially in cases where I quickly need to access an encrypted variable (e.g. a password) I really don't want to google for solutions like https://stackoverflow.com/questions/43467180/how-to-decrypt-string-with-ansible-vault-2-3-0.\r\n\r\nIt is also a problem for `git diff` use cases (https://stackoverflow.com/questions/29937195/how-to-diff-ansible-vault-changes). Is improving this state still on the roadmap? I didn't find it neither for 2.5 nor 2.6...", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM11", "speaker": "ghost", "conversation_id": "ROOT", "reply_to": "COM10", "timestamp": "2018-05-17T02:20:56Z", "text": "Hi, so I've figured out a way to do this for checking individual values, using a yaml parser, **yq** https://github.com/mikefarah/yq (there's more than one yq project, but I used this). This works with ansible 2.5.2\r\n\r\nI have a vars file, with encrypted and unencrypted values, `all.yml`\r\n\r\n```\r\nunencrypted_value: 1234\r\nencrypted_value: !vault |\r\n          $ANSIBLE_VAULT;1.1;AES256\r\n          37316535353565313063353530353539666634363834626664366263666538346131653332353932\r\n          3637363030613037316336306466656432353463383230370a396530323164353563363434663238\r\n          30336436396264656663663837346162323762333063376631326633356533376566633563386637\r\n          6531383261396366640a363339616164333630373730613564646434386364396534653063666238\r\n          6131\r\n```\r\n\r\nI have a password file, `vault-password`\r\n```\r\npassword\r\n```\r\n\r\nUsing `yq`, I'm able to decrypt the value pretty easily, by selecting the encrypted value and passing it to the decrypt function\r\n\r\n```\r\n$ yq read all.yml encrypted_value | ansible-vault --vault-id vault-password decrypt\r\nDecryption successful\r\nsecretsecret\r\n```\r\n\r\nHope this helps!", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM12", "speaker": "MarkusTeufelberger", "conversation_id": "ROOT", "reply_to": "COM11", "timestamp": "2018-05-17T11:24:52Z", "text": "Thanks, this helps if it is possible to install additional software. I would argue that ansible-vault should also have this functionality built-in.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM13", "speaker": "ghost", "conversation_id": "ROOT", "reply_to": "COM12", "timestamp": "2018-05-17T23:48:43Z", "text": "Yeah definitely that'd be the best option :)", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM14", "speaker": "brianguy", "conversation_id": "ROOT", "reply_to": "COM13", "timestamp": "2018-08-08T22:04:22Z", "text": "Also related, let rekey work on all encrypted variables in a file. There doesn't seem to be a good way to rekey all the encrypted variables, which makes encrypted variables super cumbersome now that we have to rekey (will end up having script this). Even if it just spits it back out to stdout that'd be a huge help instead of modifying the variables in the file directly.", "meta": {"posReactions": "5", "negReactions": "0"}}
{"id": "COM15", "speaker": "varac", "conversation_id": "ROOT", "reply_to": "COM14", "timestamp": "2018-08-23T07:55:52Z", "text": "Why is this issue still assigned to the `2.5 milestone` when `ansible 2.5` is already release a long time ago ? See #44556 for outdated milestones.\r\n\r\nPlease reassign to a current milestone, this is a really missing feature imo (especially the lack of rekeying functionality).", "meta": {"posReactions": "6", "negReactions": "0"}}
{"id": "COM16", "speaker": "Goobaroo", "conversation_id": "ROOT", "reply_to": "COM15", "timestamp": "2018-09-28T21:25:28Z", "text": "It would be nice if rekey worked this way as well.  Updating only the encrypted values in a mixed variable file.", "meta": {"posReactions": "2", "negReactions": "0"}}
{"id": "COM17", "speaker": "geerlingguy", "conversation_id": "ROOT", "reply_to": "COM16", "timestamp": "2019-01-15T17:21:38Z", "text": "Just giving another thumbs up on this; something like the `yq` solution above works okay and can be scripted, but having the functionality be part of `ansible-vault` itself would make management and re-keys so much simpler, and require one fewer dependency.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM18", "speaker": "boormat", "conversation_id": "ROOT", "reply_to": "COM17", "timestamp": "2019-03-25T22:21:46Z", "text": "A simple but effective solution would be to keep the existing symantecs of ansible vault encrypt, decrypt and view commands, to detect and encrypt and decrypt values of complete files.\r\n\r\nFor existing users of encrypted files, it would be trivial to convert to the enrypted values.  It could even be considered best practice is to keep encrypted values in files named such as secrets.yml, to make it easier to spot accidently unencrypted secrets.\r\n\r\nDuring the encrypt phase, it would convert any unencrypted values to encrypted values.  This would allow users to very simply add new values just by editing the \"secrets.yml\", test as required, then run the encypt command.   Users would be able to enforce or check encryption by git hooks or similar.\r\n", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM19", "speaker": "MarkusTeufelberger", "conversation_id": "ROOT", "reply_to": "COM18", "timestamp": "2019-03-25T22:44:19Z", "text": "That solution would be simple, but likely not enough. For example every variable can be encrypted with a different secret/vault identifier. Also encrypted and unencrypted variables can be mixed.\r\n\r\nI'd still like to have a way at least to decrypt all variables belonging to a vault ID transparently using `ansible-vault`. Seriously, this is a usability problem since Ansible 2.3! This makes it nearly impossible for me to use vaulted variables, since being able to run `git diff` on changes is important.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM20", "speaker": "steffann", "conversation_id": "ROOT", "reply_to": "COM19", "timestamp": "2019-06-05T10:42:20Z", "text": "This is still a problem with Ansible 2.8... A solution would be really appreciated!", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM21", "speaker": "steffann", "conversation_id": "ROOT", "reply_to": "COM20", "timestamp": "2019-06-05T12:33:33Z", "text": "For others looking for a quick solution I created this script: https://gist.github.com/steffann/240d4170e45aa3cf7cf0df5e9beaf0ba\r\n\r\nIt uses [ruamel.yaml](https://yaml.readthedocs.io/), which preserves ordering, comments etc in the YAML file. Great when depending on decent git diffs etc :)", "meta": {"posReactions": "2", "negReactions": "0"}}
{"id": "COM22", "speaker": "varac", "conversation_id": "ROOT", "reply_to": "COM21", "timestamp": "2019-06-05T14:01:47Z", "text": "maybe a bit unrelated but I like how [sops](https://github.com/mozilla/sops) does it.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM23", "speaker": "fzink", "conversation_id": "ROOT", "reply_to": "COM22", "timestamp": "2019-06-11T18:36:23Z", "text": "Running into this issue again and it sucks. Please guys, this issue has been open for almost 2 years now and for people who really use ansible-vault, this is a major pain the butt.", "meta": {"posReactions": "16", "negReactions": "0"}}
{"id": "COM24", "speaker": "joeto0", "conversation_id": "ROOT", "reply_to": "COM23", "timestamp": "2019-11-19T01:04:53Z", "text": "same issue here, we need to unencrypt all values and it is a nightmare, this must be common function", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM25", "speaker": "tom0010", "conversation_id": "ROOT", "reply_to": "COM24", "timestamp": "2019-12-05T11:25:00Z", "text": "+1 for this functionality.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM26", "speaker": "martincermak", "conversation_id": "ROOT", "reply_to": "COM25", "timestamp": "2019-12-05T14:13:48Z", "text": "+1, really need it!", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM27", "speaker": "whirlwin", "conversation_id": "ROOT", "reply_to": "COM26", "timestamp": "2020-01-07T11:51:24Z", "text": "I solved this using debug mode. E.g.\r\n\r\n`ansible localhost -m debug -a var='myVariable' -e \"@myFile.yml\" --ask-vault-pass`", "meta": {"posReactions": "6", "negReactions": "0"}}
{"id": "COM28", "speaker": "romulo-dbts", "conversation_id": "ROOT", "reply_to": "COM27", "timestamp": "2020-02-04T12:45:01Z", "text": "+1 it would be very handy!!!", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM29", "speaker": "drewhemm", "conversation_id": "ROOT", "reply_to": "COM28", "timestamp": "2020-02-06T11:39:12Z", "text": "> I solved this using debug mode. E.g.\r\n> \r\n> `ansible localhost -m debug -a var='myVariable' -e \"@myFile.yml\" --ask-vault-pass`\r\n\r\nWorks beautifully! No need for `--ask-vault-pass` if you have the password in a file identified by the `ANSIBLE_VAULT_PASSWORD_FILE` environment variable:\r\n\r\nhttps://docs.ansible.com/ansible/latest/reference_appendices/config.html#envvar-ANSIBLE_VAULT_PASSWORD_FILE", "meta": {"posReactions": "2", "negReactions": "0"}}
