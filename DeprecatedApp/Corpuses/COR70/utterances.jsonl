{"id": "ROOT", "speaker": "IainNZ", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2018-08-21T03:36:57Z", "text": "Global variable scope rules lead to unintuitive behavior at the REPL/notebook ### Example 1\r \r This came up with a student who upgraded from 0.6 to 1.0 directly, so never even got a chance to see a deprecation warning, let alone find an explanation for new behavior:\r \r ```julia\r julia> beforefor = true\r true\r \r julia> for i in 1:2\r          beforefor = false\r        end\r \r julia> beforefor  # this is surprising bit\r true\r \r julia> beforeif = true\r true\r \r julia> if 1 == 1\r          beforeif = false\r        end\r false\r \r julia> beforeif  # Another surprise!\r false\r \r julia> function foo()\r          infunc = true\r          for i in 1:10\r            infunc = false\r          end\r          @show infunc\r        end\r foo (generic function with 1 method)\r \r julia> foo()  # \"I don't get this\"\r infunc = false \r ```\r \r ### Example 2\r \r ```julia\r julia> total_lines = 0\r 0\r \r julia> list_of_files = [\"a\", \"b\", \"c\"]\r 3-element Array{String,1}:\r  \"a\"\r  \"b\"\r  \"c\"\r \r julia> for file in list_of_files\r          # fake read file\r          lines_in_file = 5\r          total_lines += lines_in_file\r        end\r ERROR: UndefVarError: total_lines not defined\r Stacktrace:\r  [1] top-level scope at ./REPL[3]:4 [inlined]\r  [2] top-level scope at ./none:0\r \r julia> total_lines  # This crushs the students willingness to learn\r 0\r ```\r \r I \"get\" why this happens in the sense that I think I can explain, with sufficient reference to the arcana in the manual about what introduces scopes and what doesn't, but I think that this is problematic for interactive use.\r \r In example one, you get a silent failure. In example two, you get an error message that is very there-is-no-spoon. Thats roughly comparable to some Python code I wrote in a notebook at work today.\r \r I'm not sure what the rules are in Python, but I do know that generally you can't assign to things at the global scope without invoking global. But at the REPL it does work, presumably because at the REPL the rules are different or the same logic as if they were all are in the scope of function is applied.\r \r I can't language-lawyer the rules enough to propose the concrete change I would like, and based on Slack this isn't even necessarily perceived as an issue by some people, so I don't know where to go with this except to flag it.\r \r Cross-refs:\r #19324\r https://discourse.julialang.org/t/repl-and-for-loops-scope-behavior-change/13514\r https://stackoverflow.com/questions/51930537/scope-of-variables-in-julia", "meta": {"posReactions": "15", "negReactions": "0"}}
{"id": "COM0", "speaker": "IainNZ", "conversation_id": "ROOT", "reply_to": "ROOT", "timestamp": "2018-08-21T03:39:24Z", "text": "(Per @mlubin, this is the relevant change https://github.com/JuliaLang/julia/pull/19324)", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM1", "speaker": "jekbradbury", "conversation_id": "ROOT", "reply_to": "COM0", "timestamp": "2018-08-21T04:18:59Z", "text": "Stefan suggested [here](https://discourse.julialang.org/t/repl-and-for-loops-scope-behavior-change/13514/9) that one possibility to solve this issue is automatic wrapping of REPL entries in `let` blocks", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM2", "speaker": "KristofferC", "conversation_id": "ROOT", "reply_to": "COM1", "timestamp": "2018-08-21T09:36:57Z", "text": "But wouldn't that be confusing in that you couldn't do\r\n\r\n```\r\na = 1\r\n```\r\n\r\nand use `a` after that? Unless `global` is inserted for all the toplevel assignments, I guess?", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM3", "speaker": "StefanKarpinski", "conversation_id": "ROOT", "reply_to": "COM2", "timestamp": "2018-08-21T12:57:46Z", "text": "The behavior wouldn't be just to wrap everything in a `let` block\u2014it's more complicated than that. You need to let-bind any global that's assigned inside the expression and then extract the let-bound value to a global at the end of the expression.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM4", "speaker": "StefanKarpinski", "conversation_id": "ROOT", "reply_to": "COM3", "timestamp": "2018-08-21T13:05:47Z", "text": "So you would turn `a = 1` into something like `a = let a; a = 1; end`. And something like\r\n```jl\r\nfor i in 1:2\r\n    before = false\r\nend\r\n```\r\nwould be turned into this:\r\n```jl\r\nbefore = let before = before\r\n    for i in 1:2\r\n        before = false\r\n    end\r\nend\r\n```\r\nFrankly, I'm pretty annoyed that people are only giving this feedback now. This has change has been on master for ten months.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM5", "speaker": "piever", "conversation_id": "ROOT", "reply_to": "COM4", "timestamp": "2018-08-21T13:38:14Z", "text": "I'm guilty of not having followed master very closed until recently, so this feedback is indeed a bit late. More than a concern for programmers (most `for` loops will be inside a function in library code) I'm afraid this is a concern for teaching. Often `for` loops are taught before functions or scopes (of course you need to understand scopes to really understand what's going on but in teaching things are often simplified).\r\n\r\nHere it becomes a bit difficult to teach a beginner how to sum numbers from 1 to 10 without explaining functions or global variables.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM6", "speaker": "mlubin", "conversation_id": "ROOT", "reply_to": "COM5", "timestamp": "2018-08-21T13:46:42Z", "text": "> Frankly, I'm pretty annoyed that people are only giving this feedback now. This has change has been on master for ten months.\r\n\r\nTo be fair, Julia 0.7 was released 13 days ago. This is a new change for most Julia users.", "meta": {"posReactions": "7", "negReactions": "0"}}
{"id": "COM7", "speaker": "IainNZ", "conversation_id": "ROOT", "reply_to": "COM6", "timestamp": "2018-08-21T13:59:17Z", "text": "> Frankly, I'm pretty annoyed that people are only giving this feedback now. This has change has been on master for ten months\r\n\r\nUnfortunately for those of us who can not handle living on the edge, its brand-new from our perspective.", "meta": {"posReactions": "14", "negReactions": "0"}}
{"id": "COM8", "speaker": "rickhg12hs", "conversation_id": "ROOT", "reply_to": "COM7", "timestamp": "2018-08-21T14:04:29Z", "text": "> Frankly, I'm pretty annoyed that people are only giving this feedback now. This has change has been on master for ten months.\r\n\r\nAnd for those of us who have been encouraged to stay off the development branches, \"it's brand-new from our perspective.\"", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM9", "speaker": "KristofferC", "conversation_id": "ROOT", "reply_to": "COM8", "timestamp": "2018-08-21T14:21:27Z", "text": "Can we please go back to focus on the issue at hand now, instead of having a meta discussion about how long people have had to test this. It is what it is right now, so let's look forward.", "meta": {"posReactions": "12", "negReactions": "0"}}
{"id": "COM10", "speaker": "ChrisRackauckas", "conversation_id": "ROOT", "reply_to": "COM9", "timestamp": "2018-08-21T14:25:47Z", "text": ">I'm guilty of not having followed master very closed until recently, so this feedback is indeed a bit late. More than a concern for programmers (most for loops will be inside a function in library code) I'm afraid this is a concern for teaching. Often for loops are taught before functions or scopes (of course you need to understand scopes to really understand what's going on but in teaching things are often simplified).\r\n\r\n>Here it becomes a bit difficult to teach a beginner how to sum numbers from 1 to 10 without explaining functions or global variables.\r\n\r\nThis is a big point. After finding out what the issue really is, it's surprising how little it actually shows up. It is less of an issue with a lot of Julia code in the wild and in tests, and it did reveal a lot of variables which were accidentally global (in both Julia Base's tests according to the original PR, and I noticed this on most of DiffEq's tests). In most cases it seems that the subtly wrong behavior isn't what you get (expecting a change in a loop), but rather expecting to be able to use a variable in a loop is what I've found to be the vast majority of where this shows up in updating test scripts to v1.0. So the good thing is that in most cases the user is presented with an error, and it's not difficult to fix.\r\n\r\nThe bad thing is that it's a little verbose to have to put `global x` inside of the loops, and now your REPL code is also different from the function code. Whether or not it's more intuitive behavior than before is a tough opinion because [there were definitely some edge cases in hard/soft local scoping](http://ucidatascienceinitiative.github.io/IntroToJulia/Html/ScopingExperiment) and so this is clearly easier to explain. But at the same time, while having a much more succinct explanation than the behavior of before, it's now easier to hit the edge cases where understanding scoping rules matters. \ud83e\udd37\u200d\u2642\ufe0f. \r\n\r\nI for one would like to see the experiments with `let` blocking. This would keep the \"you didn't really want so many globals\" aspect of it, along with the simplified scoping explanation, while at the same time make REPL code behave like function interiors (which is seemingly what we've always wanted). Or inversely, making people specify variables they want to act as globals\r\n\r\n```julia\r\nglobal x = 5\r\nfor i = 1:5\r\n  println(x+i)\r\nend\r\n```\r\n\r\ncould be a nice way to keep the explicitness, and would make the \"REPL code is slow because of globals\" be much more obvious. The downside is that once again throwing things into a function would not require the `global` markers. \r\n\r\nBut given how this tends to show up, it's not really gamebreaking or a showstopper. I'd classify it as a wart  that should get a mention in any workshop but it's not like v1.0 is unusable because of it. I hope that changing this behavior isn't classified as breaking and require v2.0 though.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM11", "speaker": "ExpandingMan", "conversation_id": "ROOT", "reply_to": "COM10", "timestamp": "2018-08-21T14:58:56Z", "text": "I'm not so sure I like the idea that the REPL should behave like a function interior.  It clearly isn't, so I expect it to behave like global scope.  To me the REPL not behaving like global scope would be potentially even more confusing than the discrepency that causes this issue.\r\n\r\nRegardless, at the very least I think that the documentation should be somewhat more explicit about this issue.  Casually reading the docs I would have assumed that you would need to use the `local` keyword to get the behavior occurs in global scope by default.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM12", "speaker": "piever", "conversation_id": "ROOT", "reply_to": "COM11", "timestamp": "2018-08-21T15:06:32Z", "text": "> I for one would like to see the experiments with `let` blocking. This would keep the \"you didn't really want so many globals\" aspect of it, along with the simplified scoping explanation, while at the same time make REPL code behave like function interiors (which is seemingly what we've always wanted)\r\n\r\nIf we're going for \"REPL is the same as the inside of a function\" we should also think about `outer`:\r\n\r\n```julia\r\njulia> i = 1\r\n1\r\n\r\njulia> for outer i = 1:10\r\n       end\r\nERROR: syntax: no outer variable declaration exists for \"for outer\"\r\n```\r\n\r\nversus:\r\n\r\n```julia\r\njulia> function f()\r\n          i = 0\r\n          for outer i = 1:10\r\n          end\r\n          return i\r\n       end\r\nf (generic function with 1 method)\r\n\r\njulia> f()\r\n10\r\n```", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM13", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM12", "timestamp": "2018-08-21T16:29:03Z", "text": "> Frankly, I'm pretty annoyed that people are only giving this feedback now. This has change has been on master for ten months.\r\n\r\nPeople haven't been using master for interactive use or for teaching, they've been using it to upgrade packages, which are only minimally affected by this and are mostly written by experienced programmers.\r\n\r\n(I was one of the few people who did give feedback in #19324, though, where I argued [for the old behavior](https://github.com/JuliaLang/julia/pull/19324#issuecomment-356484761).)\r\n\r\nA non-breaking way out of this would be to change back to the old behavior (ideally not by inserting implicit `let` blocks or anything \u2014 just restore the old code in `julia-syntax.scm` as an option) in the REPL.  Or rather, to make it available in environments like IJulia that might want it, add a `soft_global_scope=false` flag to `include`, `include_string`, and `Core.eval` to restore the old behavior.", "meta": {"posReactions": "10", "negReactions": "0"}}
{"id": "COM14", "speaker": "StefanKarpinski", "conversation_id": "ROOT", "reply_to": "COM13", "timestamp": "2018-08-21T16:52:48Z", "text": "> (I was one of the few people who did give feedback in #19324, though, where I argued for the old behavior.)\r\n\r\nYes, and I greatly appreciate it. It doesn't much matter now since we made the choice, let it bake for ten months and have now released it with a long-term commitment to stability. So the only thing to do now is to focus on what to do going forward.\r\n\r\nHaving an option to choose between the old behavior and the new one is interesting but it feels very hacky. That means we not only sometimes have a scoping behavior that everyone apparently found incredibly confusing, but we don't always have it and whether we have it or not depends on a global flag. That feels pretty unsatisfactory, I'm afraid.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM15", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM14", "timestamp": "2018-08-21T16:56:11Z", "text": "> Having an option to choose between the old behavior and the new one is interesting but it feels very hacky.\r\n\r\nIf someone implements an \"unbreak me\" soft-scope AST transformation, it will be very tempting to use it in IJulia, OhMyREPL, etcetera, at which point you get the even more problematic situation in which the default REPL is seen as broken.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM16", "speaker": "StefanKarpinski", "conversation_id": "ROOT", "reply_to": "COM15", "timestamp": "2018-08-21T17:02:31Z", "text": "That's not what I'm saying. Clearly we should use the same solution in all those contexts. But implementing it as two different variations on scoping rules seems less clean than implementing it as a code transformation with one set of scoping rules. But perhaps those are functionally equivalent. However, it seems easier to explain in terms of the new simpler scoping rules + a transformation that takes REPL-style input and transforms it before evaluating it.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM17", "speaker": "StefanKarpinski", "conversation_id": "ROOT", "reply_to": "COM16", "timestamp": "2018-08-21T17:06:55Z", "text": "That could be done as `Meta.globalize(m::Module, expr::Expr)` that transforms an expression by automatically annotating any globals which exist in the module as global if they are assigned inside of any top-level non-function scope. Of course, I think that's equivalent to what the old parser did, but a bit more transparent since you can call `Meta.globalize` yourself and see what the REPL will evaluate.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM18", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM17", "timestamp": "2018-08-21T17:07:36Z", "text": "> That could be done as `Meta.globalize(m::Module, expr::Expr)` that transforms an expression by automatically annotating any globals which exist in the module as global if they are assigned inside of any top-level non-function scope.\r\n\r\nI actually started looking into implementing something like this a few minutes ago.  However, it looks like it would be *much* easier to implement as an option in `julia-syntax.jl`:\r\n\r\n* Writing an external AST transformation is possible, but it seems like there are lots of tricky corner cases \u2014 you basically have to re-implement the scoping rules\u00a0\u2014 whereas we already had the code to get it right in `julia-syntax.scm`.\r\n* It's even more tricky for something like IJulia that currently uses `include_string` to evaluate a whole block of code and get the value of the last expression.  Not only would we have to switch to parsing expression by expression, but some hackery may be needed in order to preserve the original line numbers (for error messages etcetera).  (Though I found a [hack for ChangePrecision.jl for this sort of thing](https://github.com/stevengj/ChangePrecision.jl/blob/master/src/ChangePrecision.jl#L105-L111) that may work here also.)\r\n* Not to mention of the case of people that `include` external files, which would not be caught by your AST transformation.\r\n\r\n> However, it seems easier to explain in terms of the new simpler scoping rules + a transformation that takes REPL-style input and transforms it before evaluating it.\r\n\r\nI seriously doubt this would be easier to explain to new users than just saying that the rules are less picky for interactive use or for `include` with a certain flag.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM19", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM18", "timestamp": "2018-08-21T17:54:27Z", "text": "Here is a rough draft of a `globalize(::Module, ast)` implementation: https://gist.github.com/stevengj/255cb778efcc72a84dbf97ecbbf221fe", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM20", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM19", "timestamp": "2018-08-21T19:48:16Z", "text": "Okay, I've figured out how to implement a `globalize_include_string` function that preserves line-number information, and have added it to [my gist](https://gist.github.com/stevengj/255cb778efcc72a84dbf97ecbbf221fe).\r\n\r\nA possible (non-breaking) way forward, if people like this approach:\r\n\r\n1. Release a SoftGlobalScope.jl package with the `globalize` etc. functions.\r\n2. Use SoftGlobalScope in IJulia (and possibly Juno, vscode, and OhMyREPL).\r\n3. Fold the SoftGlobalScope functions into a future release of the REPL stdlib package and use it in the REPL.\r\n\r\nOr is it practical to roll it into REPL.jl immediately?  I'm not completely clear on how stdlib updates work in 1.0.\r\n\r\nPlease take a look at my implementation, in case I'm missing something that will cause it to be fragile.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM21", "speaker": "KristofferC", "conversation_id": "ROOT", "reply_to": "COM20", "timestamp": "2018-08-21T21:26:09Z", "text": "Can't we have it as a non-default feature of the REPL in 1.1?", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM22", "speaker": "JeffBezanson", "conversation_id": "ROOT", "reply_to": "COM21", "timestamp": "2018-08-21T21:50:05Z", "text": "Duplicate of #28523 and #28750. To those saying they don't want to teach people about global variables, I suggest teaching functions first, before `for` loops. Functions are more fundamental anyway, and this will help set the expectation that code should be written in functions. While I understand the inconvenience, this scoping behavior can be turned into a pedagogical advantage: \"In fact, global variables are such a bad idea, particularly using them in loops, that the language makes you bend over backwards to use them.\"\r\n\r\nAdding a non-default feature to the REPL for this seems ok to me though.", "meta": {"posReactions": "5", "negReactions": "5"}}
{"id": "COM23", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM22", "timestamp": "2018-08-21T23:11:58Z", "text": "@JeffBezanson, remember that many of us would like to use Julia as a substitute for Matlab etcetera in technical courses like linear algebra and statistics.  These are *not* programming courses and the students often have no programming background.   We never do structured programming \u2014 it's almost *all* interactive with short snippets and global variables.\r\n\r\nFurthermore, the reason I'm using a dynamic language in the first place is to switch fluidly between interactive exploration and more disciplined programming.   The inability to use the same code in a global and a function context is a hindrance to that end, even for someone who is used to scoping concepts, and it is much worse for students from non-CS backgrounds.", "meta": {"posReactions": "31", "negReactions": "0"}}
{"id": "COM24", "speaker": "ExpandingMan", "conversation_id": "ROOT", "reply_to": "COM23", "timestamp": "2018-08-21T23:34:20Z", "text": "> remember that many of us would like to use Julia as a substitute for Matlab etcetera in technical courses like linear algebra and statistics. These are not programming courses and the students often have no programming background. We never do structured programming \u2014 it's almost all interactive with short snippets and global variables.\r\n\r\nMany of us Julia users have absolutely 0 CS background (including myself), but it seems to me that the proper attitude (*especially* for students) is a willingness to learn rather than demanding things be changed for the worse to accommodate our naivete.\r\n\r\nNow, I'm not necessarily implying that this particular change would be for the worse as I only have a limited understanding of what's going on here, but if it *is* the case that this is a significant complication or makes it excessively easy to write needlessly badly performing code it does not seem worth it to make a change in order to have a better lecture example.  You can't change the laws of physics so that the electrostatics examples you show to freshman are more applicable to real life.\r\n\r\nSo my question as a non-CS user who also cares about performance is how would I be likely to screw up if this were made the default behavior.  Is it literally just the sorts of examples we are seeing here that are a problem (which I was already aware of), or are we likely to often screw this up badly in more subtle ways?\r\n\r\nFor what it's worth, I do agree that having code behave differently depending on its enclosing scope is a generally undesirable feature.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM25", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM24", "timestamp": "2018-08-22T00:57:15Z", "text": "Making code harder to write interactively, forcing beginners writing their first loops to understand obscure scoping rules, and making code pasted from functions not work in global scopes does not help programmers write fast code in functions. It just makes it harder to use Julia interactively and harder for beginners. ", "meta": {"posReactions": "7", "negReactions": "0"}}
{"id": "COM26", "speaker": "stevengj", "conversation_id": "ROOT", "reply_to": "COM25", "timestamp": "2018-08-22T01:10:43Z", "text": "> Can't we have it as a non-default feature of the REPL in 1.1?\r\n\r\nMaking an \"unbreak me\" option the default seems wiser, especially an option that is aimed squarely at beginning users.   If it is a non-default option, then precisely those people who need it most will be those who don't have it enabled (and don't know it exists).", "meta": {"posReactions": "9", "negReactions": "0"}}
{"id": "COM27", "speaker": "mauro3", "conversation_id": "ROOT", "reply_to": "COM26", "timestamp": "2018-08-22T06:51:02Z", "text": "What would the proposed REPL-mode do to `include`ed scripts?  Would the evaluation of global statements depend on whether the REPL mode is activated?  If so, IMO this would be at odds with the 1.0 stability promise.", "meta": {"posReactions": "0", "negReactions": "0"}}
{"id": "COM28", "speaker": "StefanKarpinski", "conversation_id": "ROOT", "reply_to": "COM27", "timestamp": "2018-08-22T07:21:58Z", "text": "If we did something like this it seems like it might make sense for the module to determine how it works. So `Main` would be a \"soft scope\" module while by default other modules would be \"hard scope\" modules.", "meta": {"posReactions": "1", "negReactions": "0"}}
{"id": "COM29", "speaker": "dawbarton", "conversation_id": "ROOT", "reply_to": "COM28", "timestamp": "2018-08-22T15:00:15Z", "text": "I was interested to see if it was possible to monkey patch the REPL to use @stevengj's `globalize` function and it appears it is without too much effort (though quite hacky). See the [gist](https://gist.github.com/dawbarton/0388715fb56fb5cd05e0e4b12c322815). This doesn't work with Juno (or anything else that calls `Core.eval` directly).\r\n\r\nI'm **not** going to be recommending this to people, but it's quite useful to me when doing quick-and-dirty data analysis. I would very much like to see a (better thought out) solution since it really is quite confusing for inexperienced and often reluctant coders (i.e., my students) when you can't copy and paste in code from a function into the REPL to see what it does and vice-versa.\r\n\r\n```julia\r\njulia> a = 0                                                                \r\n0                                                                           \r\n                                                                            \r\njulia> for i = 1:10                                                         \r\n         a += i                                                             \r\n       end                                                                  \r\nERROR: UndefVarError: a not defined                                         \r\nStacktrace:                                                                 \r\n [1] top-level scope at .\\REPL[2]:2 [inlined]                               \r\n [2] top-level scope at .\\none:0                                            \r\n                                                                            \r\njulia> using SoftGlobalScope                                                \r\n[ Info: Precompiling SoftGlobalScope [363c7d7e-a618-11e8-01c4-4f22c151e122] \r\n                                                                            \r\njulia> for i = 1:10                                                         \r\n         a += i                                                             \r\n       end                                                                  \r\n                                                                            \r\njulia> a                                                                    \r\n55                                                                          \r\n```\r\n(BTW: the above is about as much testing as it has had!)", "meta": {"posReactions": "2", "negReactions": "0"}}
