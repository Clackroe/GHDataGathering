{
    "active_lock_reason": "too heated",
    "assignee": null,
    "assignees": [],
    "author_association": "NONE",
    "body": "Today I ran into the annoying coding style issue that you have to create a complete new class just for calling a client-only method if available. Because this makes code very very ugly I created a different approach:\r\n\r\nA new `@ImplementOn` annotation can specify a method in the same class to be overwritten by another method when on a specific `Dist`. For example:\r\n\r\n```java\r\n    public void myMethod() {\r\n\r\n    }\r\n\r\n    @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r\n    private void myMethod_client() {\r\n        System.out.println(\"Client implementation\");\r\n    }\r\n\r\n    @ImplementOn(dist = Dist.DEDICATED_SERVER, method = \"myMethod\")\r\n    private void myMethod_server() {\r\n        System.out.println(\"Server implementation\");\r\n    }\r\n```\r\n\r\nThen, upon loading of this class, an ASM transformer (`net.minecraftforge.common.asm.RuntimeDistImplementor` to be precise) injects either `myMethod_client` or `myMethod_server` into the method `myMethod` and strips unused `@ImplementOn` methods so that they won't get loaded. The above example will, on `Dist.CLIENT` become:\r\n\r\n```java\r\n    public void myMethod() {\r\n        this.myMethod_client();\r\n    }\r\n\r\n    @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r\n    private void myMethod_client() {\r\n        System.out.println(\"Client implementation\");\r\n    }\r\n```\r\n\r\nNote how the method is directly delegated: this keeps line numbers and debug info understandable in stack traces. The system works for methods with or without return values, static and virtual methods, and any set of arguments. For `@ImplementOn` to work properly, the following conditions are checked, with the intentions specified:\r\n\r\n- The return types of the target method and the injected method must match **exactly**. This is because it finds the target method based on the name specified and the descriptor (including return type) of the injector method.\r\n- The argument lists of the target method and the injected method must match **exactly**. This is because it finds the target method based on the name specified and the descriptor of the injector method.\r\n- The `static` modifier must either be specified on both the target and injected method, or must be omitted on both methods. When one is static and the other isn't, the injection fails. This is because a static method can not reference an instance method. An instance method can access a static method but for the semantics of 'replacing the method' I forced the `static` modifiers to match exactly.\r\n- The injected method **must** be private. This prevents overriding which can cause strange issues as unused injected methods are stripped (subclasses might be unable to load if they call `super`). This also prevents them being called from within another class (even inner classes can't call them - this goes via a bridge method).\r\n- The injected method may never be called (only checked in a development environment, since it checks all instructions in a class and might drop performance a lot). This filters the cases where a method of the same class accesses the injector (including bridge methods), which must not happen either.\r\n- There must be, for each separate `Dist`, only one injected method: you can specify injections for the same method but for different dists. This rule is obvious: you should not inject into a method twice because you will then overwrite your own injection.\r\n\r\nNote that this works with method overloading: an `@ImplementOn` annotated method will be injected into the method with the name specified in the annotation's `method` parameter and the descriptor of the injected method. Hence this will work:\r\n\r\n```java\r\n    public void myMethod() {\r\n        System.out.println(\"Common implementation\");\r\n    }\r\n\r\n    @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r\n    private void myMethod_client() {\r\n        System.out.println(\"Client implementation\");\r\n    }\r\n\r\n    public void myMethod(int argument) {\r\n        System.out.println(\"Common implementation, argument = \" + argument);\r\n    }\r\n\r\n    @ImplementOn(dist = Dist.CLIENT, method = \"myMethod\")\r\n    private void myMethod_client(int argument) {\r\n        System.out.println(\"Client implementation, argument = \" + argument);\r\n    }\r\n```\r\n\r\nWhat's also notable here is that an `@ImplementOn` method is only injected when the `dist` parameter matches the `Dist` of the environment. When the `Dist`s don't match, the target method is left untouched and the injected method is stripped from the class, if the `Dist`s _do_ match, the contents of the target method are stripped **completely** and are overwritten by the necessary bytecode.\r\n\r\n---\r\n\r\nAs an alternative suggestion to the semantics I've implemented in the current pull request, it's also possible to make a `@DelegateOn` annotation which is put above the target method and using the `@OnlyIn` annotations for stripping sided methods. It would then look like this:\r\n\r\n```java\r\n    @DelegateOn(client = \"myMethod_client\", server = \"myMethod_server\")\r\n    public void myMethod() {\r\n\r\n    }\r\n\r\n    @OnlyIn(Dist.CLIENT)\r\n    private void myMethod_client() {\r\n        System.out.println(\"Client implementation\");\r\n    }\r\n\r\n    @OnlyIn(Dist.DEDICATED_SERVER)\r\n    private void myMethod_server() {\r\n        System.out.println(\"Server implementation\");\r\n    }\r\n```\r\n\r\nDrawback is here: the `myMethod_client` and `myMethod_server` render as unused and don't have an annotation indicating they are dynamically being injected, nor is there any visual reason not to call them.\r\n\r\n---\r\n\r\nI think this is a well-working alternative to `DistExecutor.safeCallWhenOn`, since it doesn't require the targeted method to be in a separate class, it allows the use of arguments and it works with return types.\r\n\r\n---\r\n\r\nThings that might still be necessary and which are missing now:\r\n\r\n- Checking the signatures of the methods (so that generic types and `throws` clauses do match). This is only a semantical issue though, in bytecode it's perfectly safe if a checked exception is thrown without having it in the `throws` clause and due to type erasure generics will work.",
    "closed_at": "2020-11-05T15:29:59Z",
    "closed_by": {
        "avatar_url": "https://avatars.githubusercontent.com/u/702211?v=4",
        "events_url": "https://api.github.com/users/LexManos/events{/privacy}",
        "followers_url": "https://api.github.com/users/LexManos/followers",
        "following_url": "https://api.github.com/users/LexManos/following{/other_user}",
        "gists_url": "https://api.github.com/users/LexManos/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/LexManos",
        "id": 702211,
        "login": "LexManos",
        "node_id": "MDQ6VXNlcjcwMjIxMQ==",
        "organizations_url": "https://api.github.com/users/LexManos/orgs",
        "received_events_url": "https://api.github.com/users/LexManos/received_events",
        "repos_url": "https://api.github.com/users/LexManos/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/LexManos/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/LexManos/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/LexManos"
    },
    "comments": 5,
    "comments_url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/issues/7467/comments",
    "created_at": "2020-11-05T14:39:17Z",
    "draft": false,
    "events_url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/issues/7467/events",
    "html_url": "https://github.com/MinecraftForge/MinecraftForge/pull/7467",
    "id": 736990625,
    "labels": [],
    "labels_url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/issues/7467/labels{/name}",
    "locked": true,
    "milestone": null,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NTE2MTA5ODky",
    "number": 7467,
    "performed_via_github_app": null,
    "pull_request": {
        "diff_url": "https://github.com/MinecraftForge/MinecraftForge/pull/7467.diff",
        "html_url": "https://github.com/MinecraftForge/MinecraftForge/pull/7467",
        "merged_at": null,
        "patch_url": "https://github.com/MinecraftForge/MinecraftForge/pull/7467.patch",
        "url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/pulls/7467"
    },
    "reactions": {
        "+1": 2,
        "-1": 3,
        "confused": 0,
        "eyes": 0,
        "heart": 0,
        "hooray": 0,
        "laugh": 0,
        "rocket": 0,
        "total_count": 5,
        "url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/issues/7467/reactions"
    },
    "repository_url": "https://api.github.com/repos/MinecraftForge/MinecraftForge",
    "state": "closed",
    "state_reason": null,
    "timeline_url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/issues/7467/timeline",
    "title": "Add annotation-based tools for dist-based implementation of methods",
    "updated_at": "2020-11-05T15:55:17Z",
    "url": "https://api.github.com/repos/MinecraftForge/MinecraftForge/issues/7467",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/11669132?v=4",
        "events_url": "https://api.github.com/users/FoxSamu/events{/privacy}",
        "followers_url": "https://api.github.com/users/FoxSamu/followers",
        "following_url": "https://api.github.com/users/FoxSamu/following{/other_user}",
        "gists_url": "https://api.github.com/users/FoxSamu/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/FoxSamu",
        "id": 11669132,
        "login": "FoxSamu",
        "node_id": "MDQ6VXNlcjExNjY5MTMy",
        "organizations_url": "https://api.github.com/users/FoxSamu/orgs",
        "received_events_url": "https://api.github.com/users/FoxSamu/received_events",
        "repos_url": "https://api.github.com/users/FoxSamu/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/FoxSamu/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/FoxSamu/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/FoxSamu"
    }
}