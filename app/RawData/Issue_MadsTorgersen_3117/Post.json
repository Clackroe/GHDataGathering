{
    "active_lock_reason": "too heated",
    "assignee": {
        "avatar_url": "https://avatars.githubusercontent.com/u/6677272?v=4",
        "events_url": "https://api.github.com/users/MadsTorgersen/events{/privacy}",
        "followers_url": "https://api.github.com/users/MadsTorgersen/followers",
        "following_url": "https://api.github.com/users/MadsTorgersen/following{/other_user}",
        "gists_url": "https://api.github.com/users/MadsTorgersen/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/MadsTorgersen",
        "id": 6677272,
        "login": "MadsTorgersen",
        "node_id": "MDQ6VXNlcjY2NzcyNzI=",
        "organizations_url": "https://api.github.com/users/MadsTorgersen/orgs",
        "received_events_url": "https://api.github.com/users/MadsTorgersen/received_events",
        "repos_url": "https://api.github.com/users/MadsTorgersen/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/MadsTorgersen/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/MadsTorgersen/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/MadsTorgersen"
    },
    "assignees": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/6677272?v=4",
            "events_url": "https://api.github.com/users/MadsTorgersen/events{/privacy}",
            "followers_url": "https://api.github.com/users/MadsTorgersen/followers",
            "following_url": "https://api.github.com/users/MadsTorgersen/following{/other_user}",
            "gists_url": "https://api.github.com/users/MadsTorgersen/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MadsTorgersen",
            "id": 6677272,
            "login": "MadsTorgersen",
            "node_id": "MDQ6VXNlcjY2NzcyNzI=",
            "organizations_url": "https://api.github.com/users/MadsTorgersen/orgs",
            "received_events_url": "https://api.github.com/users/MadsTorgersen/received_events",
            "repos_url": "https://api.github.com/users/MadsTorgersen/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MadsTorgersen/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MadsTorgersen/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MadsTorgersen"
        }
    ],
    "author_association": "CONTRIBUTOR",
    "body": "# Top level statements and functions\r\n\r\nThere are at least three somewhat conflicting scenarios around allowing statements and/or functions to be declared at the top level of program text. \r\n\r\nFirst I'll consider each in turn, and point out how they conflict with each other. Then I'll propose an approach for C# to take.\r\n\r\n## Scenario 1: Simple programs\r\n\r\nThere's a certain amount of boilerplate surrounding even the simplest of programs, because of the need for an explicit `Main` method. This seems to get in the way of language learning and program clarity.\r\n\r\nThe simplest feature to address this would be to allow a sequence of *statements* to occur right before the *namespace_member_declaration*s of a *compilation_unit* (i.e. source file).\r\n\r\nThe semantics are that if such a sequence of *statements* is present, the following type declaration would be emitted:\r\n\r\n``` c#\r\nstatic class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        // statements\r\n    }\r\n}\r\n```\r\n\r\nThis would make it an error for multiple compilation units to have statements, because you'd get two classes with the same name `Program`. If the assembly is run, it would also be an error to have other valid entry points, such as explicit `Main` methods.\r\n\r\n## Scenario 2: Top-level functions\r\n\r\nC# restricts named functions to being declared as members of types, as well as local functions. The closest you can get to a notion of \"global\" (or \"namespace-global\") functions is to put them as static members in a class `C` and then say `using static C;` in places where you want to use the functions directly without prefixing with a class name. This adds ceremony to both the declaring side and the consuming side dealing with the class `C`.\r\n\r\nThe simplest feature to address this is to add function declarations to *namespace-member_declaration*s - the kind of thing you can declare globally or in a namespace.\r\n\r\nThe functions would be limited in the modifiers that apply: They cannot be `abstract`, `virtual`, `override` or `sealed`. Their accessibility, like that of top-level classes would be `internal` or `public`, with `internal` being the default. \r\n\r\nThere's a design decision as to which kinds of function member declarations would be allowed: methods are key, but properties, indexers, etc. could also be considered. You could even consider stateful members (fields, auto-properties), and you would essentially get global variables. User defined operators and conversions are probably completely off the table, though, as they have relationships with their enclosing type, and there wouldn't be one.\r\n\r\nOn the consuming side, the top-level members would be direct members of the namespace, just as top level types are. If the namespace is `using`ed, or is the global namespace, the members are directly in scope.\r\n\r\nThe implementation would be that a partial class is generated to wrap the members as static members. The class name would probably be unspeakable, and would be chosen in such a way that the same name wouldn't be used twice in the same namespace across different assemblies. If any of the top-level members are public, the class would be public, and marked in such a way that a consuming assembly would know to expose the members directly.\r\n\r\n## Scenario 3: Scripting\r\n\r\nThere is currently a \"scripting dialect\" of C#, where top-level statements and functions are not only *allowed*, but are *the* way the program is specified. It's similar to scenario 1, except that the statements are freely scattered among type declarations. (Namespace declarations are currently not allowed in scripting, but that may change in the future.)\r\n\r\nThe execution of a script is often performed by a \"host\", that is able to put specific things into scope of the script, as well as access the state of its \"local\" variables. This is enabled by the state being represented as instance fields of a generated class, of which the running script is an instance.\r\n\r\nAlso, scripts can be executed as individual \"submissions\", one after the other, with subsequent ones being within the scope of their predecessors' declarations, modulo shadowing. In this mode submissions need to be captured as objects, and cannot allow stack-only things such as ref variables. Similarly, scripts are implicitly `async` so that `await` can be used freely, and this also limits the use of certain features.\r\n\r\nIf we want to add top level statements and functions to C#, we don't want them to conflict with how those work in scripting. Rather we want to compile them in the requisite manner when necessary, but unify on the semantics of the features. This doesn't fully eliminate the scripting dialect, as we would still need to deal with the special directives and \"magic commands\" that it requires, but at the minimum we do need to avoid the same syntax to not mean materially different things.\r\n\r\n## Problem\r\n\r\nThe main conflict between these three scenarios is in how top-level functions are construed. Are they \"local-to-the-main-program\" functions (as in 1 and 3), or are they top level library declarations just like types (as in 2)?\r\n\r\nIf the former, then top-level functions can only occur as part of a top-level program. They can see the local variables of that program, but they (and the local variables themselves) aren't visible to e.g. adjacent type declarations.\r\n\r\nIf the latter, then top-level functions can occur everywhere top-level type declarations can occur. They wouldn't be able to access the state of a top-level program, unless we also interpret the \"locals\" of such a program as top-level \"global\" variables. The functions - as well as such global variables if we choose to embrace them - would be members of their namespace, visible to any code in the assembly, and, if declared `public`, to any other assemblies referencing it.\r\n\r\n# Proposal: Simple programs\r\n\r\nYou can squint and imagine a merged feature that serves all the scenarios. It would require a lot of design work, and some corners cut. I do not propose that. Instead I suggest that we fully embrace scenario 1, essentially fleshing out and slightly generalizing the feature sketched out for that scenario above.\r\n\r\nThe primary goal of the feature therefore is to allow C# programs without unnecessary boilerplate around them, for the sake of learners and the clarity of code. A secondary but important goal is to not introduce a fundamental conflict with scenarios 2 (which we may want to revisit in the future) and 3 (not having the meaning of top-level code differ between \"program\" and \"script\" scenarios).\r\n\r\nIt should be relatively straightforward to ensure that, while more restrictive than scenario 3, for programs that *are* allowed, the semantics will be approximately the same; enough so that the two don't materially conflict. \r\n\r\nThe approach more fundamentally clashes with scenario 2, and in its straightforward form it would bar us from extending the feature to embrace scenario 2 in the future. I propose that we build in additional restrictions to keep that design space open.\r\n\r\n(If we later find that there's a need for libraries of top-level functions, we can also consider an equivalent to VB's *modules*, which still provide a named wrapper for static members (similar to a static class), but put the names of those members in scope implicitly when the enclosing namespace is `using`ed, instead of requiring an explicit `using static`).\r\n\r\n## Syntax\r\n\r\nThe only additional syntax is allowing a sequence of *statement*s in a compilation unit, just before the *namespace_member_declaration*s:\r\n\r\n``` antlr\r\ncompilation_unit\r\n    : extern_alias_directive* using_directive* global_attributes? statement* namespace_member_declaration*\r\n    ;\r\n```\r\n\r\nIn all but one *compilation_unit* the *statement*s must all be local function declarations. \r\n\r\nExample:\r\n\r\n``` c#\r\n// File 1 - any statements\r\nif (args.Length == 0\r\n    || !int.TryParse(args[0], out int n)\r\n    || n < 0) return;\r\nConsole.WriteLine(Fib(n).curr);\r\n\r\n// File 2 - only local functions\r\n(int curr, int prev) Fib(int i)\r\n{\r\n    if (i == 0) return (1, 0);\r\n    var (curr, prev) = Fib(i - 1);\r\n    return (curr + prev, curr);\r\n}\r\n```\r\n\r\nNote the use of `return` as a top-level statement. We may find that this looks/feels wrong since it's not visibly inside a body of a member. \r\n\r\n## Semantics\r\n\r\nIf any top-level statements are present in any compilation unit of the program, the meaning is as if they were combined in the block body of a `Main` method of a `Program` class in the global namespace, as follows:\r\n\r\n``` c#\r\nstatic class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        // File 1 statements\r\n        // File 2 local functions\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nIf any one compilation unit has statements other than local function declarations, those statements occur first. The order of statement contributions (which would all be local functions) from other compilation units is undefined.\r\n\r\nWarnings about missing `await` expressions are omitted. \r\n\r\nNormally collision between multiple `Main` method entry points is only diagnosed if and when the program is run. However, we should consider forbidding any `Main` methods suitable as entry points to coexist with top-level statements. Or if we do allow them, we should not allow synchronous ones to silently take precedence over the async one generated from the top-level statements. That precedence was only reluctantly allowed over async `Main` methods for back compat reasons which do not apply here.\r\n\r\nThe example above would yield the following `Main` method declaration:\r\n\r\n``` c#\r\nstatic class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        // Statements from File 1\r\n        if (args.Length == 0\r\n            || !int.TryParse(args[0], out int n)\r\n            || n < 0) return;\r\n        Console.WriteLine(Fib(n).curr);\r\n        \r\n        // Local functions from File 2\r\n        (int curr, int prev) Fib(int i)\r\n        {\r\n            if (i == 0) return (1, 0);\r\n            var (curr, prev) = Fib(i - 1);\r\n            return (curr + prev, curr);\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n## Scope of top-level parameters, local variables and local functions\r\n\r\nEven though the `args` parameter and top-level local variables and functions are \"wrapped\" into the generated `Main` method, they should still be in scope throughout the program, as if they were declared with internal accessibility in the global namespace. \r\n\r\nThis could lead to name collisions, ambiguous lookups and shadowing of imported names. If one is picked by name look-up, it should lead to an error instead of being silently bypassed. \r\n\r\nIn this way we protect our future ability to better address scenario 2, and are able to give useful diagnostics to users who mistakenly believe them to be supported.\r\n\r\nLDM notes:\r\n- https://github.com/dotnet/csharplang/blob/master/meetings/2020/LDM-2020-01-22.md",
    "closed_at": null,
    "closed_by": null,
    "comments": 91,
    "comments_url": "https://api.github.com/repos/dotnet/csharplang/issues/3117/comments",
    "created_at": "2020-01-21T21:12:24Z",
    "events_url": "https://api.github.com/repos/dotnet/csharplang/issues/3117/events",
    "html_url": "https://github.com/dotnet/csharplang/issues/3117",
    "id": 553132245,
    "labels": [
        {
            "color": "fbca04",
            "default": false,
            "description": null,
            "id": 513192173,
            "name": "Proposal",
            "node_id": "MDU6TGFiZWw1MTMxOTIxNzM=",
            "url": "https://api.github.com/repos/dotnet/csharplang/labels/Proposal"
        },
        {
            "color": "fef2c0",
            "default": false,
            "description": null,
            "id": 536034773,
            "name": "Proposal champion",
            "node_id": "MDU6TGFiZWw1MzYwMzQ3NzM=",
            "url": "https://api.github.com/repos/dotnet/csharplang/labels/Proposal%20champion"
        }
    ],
    "labels_url": "https://api.github.com/repos/dotnet/csharplang/issues/3117/labels{/name}",
    "locked": true,
    "milestone": {
        "closed_at": null,
        "closed_issues": 8,
        "created_at": "2018-06-11T18:22:13Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/3804346?v=4",
            "events_url": "https://api.github.com/users/gafter/events{/privacy}",
            "followers_url": "https://api.github.com/users/gafter/followers",
            "following_url": "https://api.github.com/users/gafter/following{/other_user}",
            "gists_url": "https://api.github.com/users/gafter/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/gafter",
            "id": 3804346,
            "login": "gafter",
            "node_id": "MDQ6VXNlcjM4MDQzNDY=",
            "organizations_url": "https://api.github.com/users/gafter/orgs",
            "received_events_url": "https://api.github.com/users/gafter/received_events",
            "repos_url": "https://api.github.com/users/gafter/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/gafter/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gafter/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/gafter"
        },
        "description": "These features have been considered by the LDT and rejected as candidates for a future version of C#.",
        "due_on": null,
        "html_url": "https://github.com/dotnet/csharplang/milestone/13",
        "id": 3416637,
        "labels_url": "https://api.github.com/repos/dotnet/csharplang/milestones/13/labels",
        "node_id": "MDk6TWlsZXN0b25lMzQxNjYzNw==",
        "number": 13,
        "open_issues": 21,
        "state": "open",
        "title": "Likely Never",
        "updated_at": "2022-10-06T18:08:28Z",
        "url": "https://api.github.com/repos/dotnet/csharplang/milestones/13"
    },
    "node_id": "MDU6SXNzdWU1NTMxMzIyNDU=",
    "number": 3117,
    "performed_via_github_app": null,
    "reactions": {
        "+1": 101,
        "-1": 8,
        "confused": 0,
        "eyes": 6,
        "heart": 19,
        "hooray": 17,
        "laugh": 0,
        "rocket": 0,
        "total_count": 151,
        "url": "https://api.github.com/repos/dotnet/csharplang/issues/3117/reactions"
    },
    "repository_url": "https://api.github.com/repos/dotnet/csharplang",
    "state": "open",
    "state_reason": null,
    "timeline_url": "https://api.github.com/repos/dotnet/csharplang/issues/3117/timeline",
    "title": "Top-level statements and functions",
    "updated_at": "2020-11-17T13:15:52Z",
    "url": "https://api.github.com/repos/dotnet/csharplang/issues/3117",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/6677272?v=4",
        "events_url": "https://api.github.com/users/MadsTorgersen/events{/privacy}",
        "followers_url": "https://api.github.com/users/MadsTorgersen/followers",
        "following_url": "https://api.github.com/users/MadsTorgersen/following{/other_user}",
        "gists_url": "https://api.github.com/users/MadsTorgersen/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/MadsTorgersen",
        "id": 6677272,
        "login": "MadsTorgersen",
        "node_id": "MDQ6VXNlcjY2NzcyNzI=",
        "organizations_url": "https://api.github.com/users/MadsTorgersen/orgs",
        "received_events_url": "https://api.github.com/users/MadsTorgersen/received_events",
        "repos_url": "https://api.github.com/users/MadsTorgersen/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/MadsTorgersen/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/MadsTorgersen/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/MadsTorgersen"
    }
}